// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// tslint:disable:no-require-imports no-var-requires import-name no-function-expression no-any prefer-template no-console no-var-self
// Most of the source is in node_modules/vscode/lib/testrunner.js
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

const fs = require("fs-extra");

const glob = require("glob");

const istanbul = require("istanbul");

const Mocha = require("mocha");

const path = require("path");

const remapIstanbul = require('remap-istanbul');

const reactHelpers_1 = require("./datascience/reactHelpers"); // Linux: prevent a weird NPE when mocha on Linux requires the window size from the TTY.
// Since we are not running in a tty environment, we just implement the method statically.


const tty = require('tty');

if (!tty.getWindowSize) {
  tty.getWindowSize = function () {
    return [80, 75];
  };
}

let mocha = new Mocha({
  ui: 'tdd',
  useColors: true
});
let testFilesGlob = 'test';
let coverageOptions;

function configure(setupOptions, coverageOpts) {
  if (setupOptions.testFilesSuffix) {
    testFilesGlob = setupOptions.testFilesSuffix;
  }

  mocha = new Mocha(setupOptions);
  coverageOptions = coverageOpts;
}

exports.configure = configure;

function run(testsRoot, callback) {
  // Enable source map support.
  require('source-map-support').install(); // nteract/transforms-full expects to run in the browser so we have to fake
  // parts of the browser here.


  reactHelpers_1.setUpDomEnvironment(); // Check whether code coverage is enabled.

  const options = getCoverageOptions(testsRoot);

  if (options && options.enabled) {
    // Setup coverage pre-test, including post-test hook to report.
    // tslint:disable-next-line:no-use-before-declare
    const coverageRunner = new CoverageRunner(options, testsRoot, callback);
    coverageRunner.setupCoverage();
  } // Run the tests.


  glob(`**/**.${testFilesGlob}.js`, {
    ignore: ['**/**.unit.test.js', '**/**.functional.test.js'],
    cwd: testsRoot
  }, (error, files) => {
    if (error) {
      return callback(error);
    }

    try {
      files.forEach(file => mocha.addFile(path.join(testsRoot, file)));
      mocha.run(failures => callback(undefined, failures));
    } catch (error) {
      return callback(error);
    }
  });
}

exports.run = run;

function getCoverageOptions(testsRoot) {
  if (!coverageOptions) {
    return undefined;
  }

  const coverConfigPath = path.join(testsRoot, coverageOptions.coverageConfig);
  return fs.existsSync(coverConfigPath) ? JSON.parse(fs.readFileSync(coverConfigPath, 'utf8')) : undefined;
}

class CoverageRunner {
  constructor(options, testsRoot, endRunCallback) {
    this.options = options;
    this.testsRoot = testsRoot;
    this.coverageVar = `$$cov_${new Date().getTime()}$$`;
    this.sourceFiles = [];

    if (!options.relativeSourcePath) {
      endRunCallback(new Error('Error - relativeSourcePath must be defined for code coverage to work'));
    }
  }

  get coverage() {
    if (global[this.coverageVar] === undefined || Object.keys(global[this.coverageVar]).length === 0) {
      console.error('No coverage information was collected, exit without writing coverage information');
      return {};
    } else {
      return global[this.coverageVar];
    }
  }

  set coverage(value) {
    global[this.coverageVar] = value;
  }
  /**
   * Information on hooking up code coverage can be found here:
   * http://tannguyen.org/2017/04/gulp-mocha-and-istanbul/
   * http://gotwarlost.github.io/istanbul/public/apidocs/classes/HookOptions.html
   * @memberof CoverageRunner
   */


  setupCoverage() {
    const reportingDir = path.join(this.testsRoot, this.options.relativeCoverageDir);
    fs.emptyDirSync(reportingDir); // Set up Code Coverage, hooking require so that instrumented code is returned.

    this.instrumenter = new istanbul.Instrumenter({
      coverageVariable: this.coverageVar
    });
    const sourceRoot = path.join(this.testsRoot, this.options.relativeSourcePath); // Glob source files

    const srcFiles = glob.sync('**/**.js', {
      ignore: this.options.ignorePatterns,
      cwd: sourceRoot
    }); // Create a match function - taken from the run-with-cover.js in istanbul.

    const decache = require('decache');

    const fileMap = new Set();
    srcFiles.map(file => path.join(sourceRoot, file)).forEach(fullPath => {
      fileMap.add(fullPath); // On Windows, extension is loaded pre-test hooks and this mean we lose
      // our chance to hook the Require call. In order to instrument the code
      // we have to decache the JS file so on next load it gets instrumented.
      // This doesn't impact tests, but is a concern if we had some integration
      // tests that relied on VSCode accessing our module since there could be
      // some shared global state that we lose.

      decache(fullPath);
    });

    const matchFn = file => fileMap.has(file);

    this.sourceFiles = Array.from(fileMap.keys()); // http://gotwarlost.github.io/istanbul/public/apidocs/classes/Hook.html#method_hookRequire.
    // Hook up to the Require function so that when this is called, if any of our source files
    // are required, the instrumented version is pulled in instead. These instrumented versions
    // write to a global coverage variable with hit counts whenever they are accessed.

    const transformer = this.instrumenter.instrumentSync.bind(this.instrumenter);
    const hookOpts = {
      verbose: false,
      extensions: ['.js']
    };
    istanbul.hook.hookRequire(matchFn, transformer, hookOpts); // Initialize the global variable to store instrumentation details.
    // http://gotwarlost.github.io/istanbul/public/apidocs/classes/Instrumenter.html.

    this.coverage = {}; // Hook the process exit event to handle reporting,
    // Only report coverage if the process is exiting successfully.

    process.on('exit', () => this.reportCoverage());
  }
  /**
   * Writes a coverage report. Note that as this is called in the process exit callback, all calls must be synchronous.
   * @returns {void}
   * @memberOf CoverageRunner
   */


  reportCoverage() {
    istanbul.hook.unhookRequire();
    const coverage = this.coverage; // Files that are not touched by code ran by the test runner is manually instrumented, to
    // illustrate the missing coverage.

    this.sourceFiles.filter(file => !coverage[file]).forEach(file => {
      this.instrumenter.instrumentSync(fs.readFileSync(file, 'utf-8'), file); // When instrumenting the code, istanbul will give each FunctionDeclaration a value of 1 in coverState.s,
      // presumably to compensate for function hoisting. We need to reset this, as the function was not hoisted,
      // as it was never loaded.

      Object.keys(this.instrumenter.coverState.s).forEach(key => this.instrumenter.coverState.s[key] = 0);
      coverage[file] = this.instrumenter.coverState;
    });
    const reportingDir = path.join(this.testsRoot, this.options.relativeCoverageDir);
    const coverageFile = path.join(reportingDir, 'coverage.json');
    fs.mkdirsSync(reportingDir);
    fs.writeFileSync(coverageFile, JSON.stringify(coverage), 'utf8');
    const remappedCollector = remapIstanbul.remap(coverage, {
      warn: warning => {
        // We expect some warnings as any JS file without a typescript mapping will cause this.
        // By default, we'll skip printing these to the console as it clutters it up.
        if (this.options.verbose) {
          console.warn(warning);
        }
      }
    });
    const reporter = new istanbul.Reporter(undefined, reportingDir);
    const reportTypes = Array.isArray(this.options.reports) ? this.options.reports : ['lcov'];
    reporter.addAll(reportTypes);
    reporter.write(remappedCollector, true, () => console.log(`reports written to ${reportingDir}`));
  }

}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInRlc3RSdW5uZXIuanMiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJmcyIsInJlcXVpcmUiLCJnbG9iIiwiaXN0YW5idWwiLCJNb2NoYSIsInBhdGgiLCJyZW1hcElzdGFuYnVsIiwicmVhY3RIZWxwZXJzXzEiLCJ0dHkiLCJnZXRXaW5kb3dTaXplIiwibW9jaGEiLCJ1aSIsInVzZUNvbG9ycyIsInRlc3RGaWxlc0dsb2IiLCJjb3ZlcmFnZU9wdGlvbnMiLCJjb25maWd1cmUiLCJzZXR1cE9wdGlvbnMiLCJjb3ZlcmFnZU9wdHMiLCJ0ZXN0RmlsZXNTdWZmaXgiLCJydW4iLCJ0ZXN0c1Jvb3QiLCJjYWxsYmFjayIsImluc3RhbGwiLCJzZXRVcERvbUVudmlyb25tZW50Iiwib3B0aW9ucyIsImdldENvdmVyYWdlT3B0aW9ucyIsImVuYWJsZWQiLCJjb3ZlcmFnZVJ1bm5lciIsIkNvdmVyYWdlUnVubmVyIiwic2V0dXBDb3ZlcmFnZSIsImlnbm9yZSIsImN3ZCIsImVycm9yIiwiZmlsZXMiLCJmb3JFYWNoIiwiZmlsZSIsImFkZEZpbGUiLCJqb2luIiwiZmFpbHVyZXMiLCJ1bmRlZmluZWQiLCJjb3ZlckNvbmZpZ1BhdGgiLCJjb3ZlcmFnZUNvbmZpZyIsImV4aXN0c1N5bmMiLCJKU09OIiwicGFyc2UiLCJyZWFkRmlsZVN5bmMiLCJjb25zdHJ1Y3RvciIsImVuZFJ1bkNhbGxiYWNrIiwiY292ZXJhZ2VWYXIiLCJEYXRlIiwiZ2V0VGltZSIsInNvdXJjZUZpbGVzIiwicmVsYXRpdmVTb3VyY2VQYXRoIiwiRXJyb3IiLCJjb3ZlcmFnZSIsImdsb2JhbCIsImtleXMiLCJsZW5ndGgiLCJjb25zb2xlIiwicmVwb3J0aW5nRGlyIiwicmVsYXRpdmVDb3ZlcmFnZURpciIsImVtcHR5RGlyU3luYyIsImluc3RydW1lbnRlciIsIkluc3RydW1lbnRlciIsImNvdmVyYWdlVmFyaWFibGUiLCJzb3VyY2VSb290Iiwic3JjRmlsZXMiLCJzeW5jIiwiaWdub3JlUGF0dGVybnMiLCJkZWNhY2hlIiwiZmlsZU1hcCIsIlNldCIsIm1hcCIsImZ1bGxQYXRoIiwiYWRkIiwibWF0Y2hGbiIsImhhcyIsIkFycmF5IiwiZnJvbSIsInRyYW5zZm9ybWVyIiwiaW5zdHJ1bWVudFN5bmMiLCJiaW5kIiwiaG9va09wdHMiLCJ2ZXJib3NlIiwiZXh0ZW5zaW9ucyIsImhvb2siLCJob29rUmVxdWlyZSIsInByb2Nlc3MiLCJvbiIsInJlcG9ydENvdmVyYWdlIiwidW5ob29rUmVxdWlyZSIsImZpbHRlciIsImNvdmVyU3RhdGUiLCJzIiwia2V5IiwiY292ZXJhZ2VGaWxlIiwibWtkaXJzU3luYyIsIndyaXRlRmlsZVN5bmMiLCJzdHJpbmdpZnkiLCJyZW1hcHBlZENvbGxlY3RvciIsInJlbWFwIiwid2FybiIsIndhcm5pbmciLCJyZXBvcnRlciIsIlJlcG9ydGVyIiwicmVwb3J0VHlwZXMiLCJpc0FycmF5IiwicmVwb3J0cyIsImFkZEFsbCIsIndyaXRlIiwibG9nIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0JDLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUVDLEVBQUFBLEtBQUssRUFBRTtBQUFULENBQTdDOztBQUNBLE1BQU1DLEVBQUUsR0FBR0MsT0FBTyxDQUFDLFVBQUQsQ0FBbEI7O0FBQ0EsTUFBTUMsSUFBSSxHQUFHRCxPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxNQUFNRSxRQUFRLEdBQUdGLE9BQU8sQ0FBQyxVQUFELENBQXhCOztBQUNBLE1BQU1HLEtBQUssR0FBR0gsT0FBTyxDQUFDLE9BQUQsQ0FBckI7O0FBQ0EsTUFBTUksSUFBSSxHQUFHSixPQUFPLENBQUMsTUFBRCxDQUFwQjs7QUFDQSxNQUFNSyxhQUFhLEdBQUdMLE9BQU8sQ0FBQyxnQkFBRCxDQUE3Qjs7QUFDQSxNQUFNTSxjQUFjLEdBQUdOLE9BQU8sQ0FBQyw0QkFBRCxDQUE5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Q0ssTUFBVCxDQUFnQkgsV0FBaEI7QUFDQUYsSUFBQUEsUUFBUSxDQUFDTSxLQUFULENBQWVWLGlCQUFmLEVBQWtDLElBQWxDLEVBQXdDLE1BQU16QyxPQUFPLENBQUNvRCxHQUFSLENBQWEsc0JBQXFCbkQsWUFBYSxFQUEvQyxDQUE5QztBQUNIOztBQTNHZ0IiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbi8vIHRzbGludDpkaXNhYmxlOm5vLXJlcXVpcmUtaW1wb3J0cyBuby12YXItcmVxdWlyZXMgaW1wb3J0LW5hbWUgbm8tZnVuY3Rpb24tZXhwcmVzc2lvbiBuby1hbnkgcHJlZmVyLXRlbXBsYXRlIG5vLWNvbnNvbGUgbm8tdmFyLXNlbGZcbi8vIE1vc3Qgb2YgdGhlIHNvdXJjZSBpcyBpbiBub2RlX21vZHVsZXMvdnNjb2RlL2xpYi90ZXN0cnVubmVyLmpzXG4ndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmcy1leHRyYVwiKTtcbmNvbnN0IGdsb2IgPSByZXF1aXJlKFwiZ2xvYlwiKTtcbmNvbnN0IGlzdGFuYnVsID0gcmVxdWlyZShcImlzdGFuYnVsXCIpO1xuY29uc3QgTW9jaGEgPSByZXF1aXJlKFwibW9jaGFcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCByZW1hcElzdGFuYnVsID0gcmVxdWlyZSgncmVtYXAtaXN0YW5idWwnKTtcbmNvbnN0IHJlYWN0SGVscGVyc18xID0gcmVxdWlyZShcIi4vZGF0YXNjaWVuY2UvcmVhY3RIZWxwZXJzXCIpO1xuLy8gTGludXg6IHByZXZlbnQgYSB3ZWlyZCBOUEUgd2hlbiBtb2NoYSBvbiBMaW51eCByZXF1aXJlcyB0aGUgd2luZG93IHNpemUgZnJvbSB0aGUgVFRZLlxuLy8gU2luY2Ugd2UgYXJlIG5vdCBydW5uaW5nIGluIGEgdHR5IGVudmlyb25tZW50LCB3ZSBqdXN0IGltcGxlbWVudCB0aGUgbWV0aG9kIHN0YXRpY2FsbHkuXG5jb25zdCB0dHkgPSByZXF1aXJlKCd0dHknKTtcbmlmICghdHR5LmdldFdpbmRvd1NpemUpIHtcbiAgICB0dHkuZ2V0V2luZG93U2l6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFs4MCwgNzVdOyB9O1xufVxubGV0IG1vY2hhID0gbmV3IE1vY2hhKHtcbiAgICB1aTogJ3RkZCcsXG4gICAgdXNlQ29sb3JzOiB0cnVlXG59KTtcbmxldCB0ZXN0RmlsZXNHbG9iID0gJ3Rlc3QnO1xubGV0IGNvdmVyYWdlT3B0aW9ucztcbmZ1bmN0aW9uIGNvbmZpZ3VyZShzZXR1cE9wdGlvbnMsIGNvdmVyYWdlT3B0cykge1xuICAgIGlmIChzZXR1cE9wdGlvbnMudGVzdEZpbGVzU3VmZml4KSB7XG4gICAgICAgIHRlc3RGaWxlc0dsb2IgPSBzZXR1cE9wdGlvbnMudGVzdEZpbGVzU3VmZml4O1xuICAgIH1cbiAgICBtb2NoYSA9IG5ldyBNb2NoYShzZXR1cE9wdGlvbnMpO1xuICAgIGNvdmVyYWdlT3B0aW9ucyA9IGNvdmVyYWdlT3B0cztcbn1cbmV4cG9ydHMuY29uZmlndXJlID0gY29uZmlndXJlO1xuZnVuY3Rpb24gcnVuKHRlc3RzUm9vdCwgY2FsbGJhY2spIHtcbiAgICAvLyBFbmFibGUgc291cmNlIG1hcCBzdXBwb3J0LlxuICAgIHJlcXVpcmUoJ3NvdXJjZS1tYXAtc3VwcG9ydCcpLmluc3RhbGwoKTtcbiAgICAvLyBudGVyYWN0L3RyYW5zZm9ybXMtZnVsbCBleHBlY3RzIHRvIHJ1biBpbiB0aGUgYnJvd3NlciBzbyB3ZSBoYXZlIHRvIGZha2VcbiAgICAvLyBwYXJ0cyBvZiB0aGUgYnJvd3NlciBoZXJlLlxuICAgIHJlYWN0SGVscGVyc18xLnNldFVwRG9tRW52aXJvbm1lbnQoKTtcbiAgICAvLyBDaGVjayB3aGV0aGVyIGNvZGUgY292ZXJhZ2UgaXMgZW5hYmxlZC5cbiAgICBjb25zdCBvcHRpb25zID0gZ2V0Q292ZXJhZ2VPcHRpb25zKHRlc3RzUm9vdCk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgIC8vIFNldHVwIGNvdmVyYWdlIHByZS10ZXN0LCBpbmNsdWRpbmcgcG9zdC10ZXN0IGhvb2sgdG8gcmVwb3J0LlxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdXNlLWJlZm9yZS1kZWNsYXJlXG4gICAgICAgIGNvbnN0IGNvdmVyYWdlUnVubmVyID0gbmV3IENvdmVyYWdlUnVubmVyKG9wdGlvbnMsIHRlc3RzUm9vdCwgY2FsbGJhY2spO1xuICAgICAgICBjb3ZlcmFnZVJ1bm5lci5zZXR1cENvdmVyYWdlKCk7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgdGVzdHMuXG4gICAgZ2xvYihgKiovKiouJHt0ZXN0RmlsZXNHbG9ifS5qc2AsIHsgaWdub3JlOiBbJyoqLyoqLnVuaXQudGVzdC5qcycsICcqKi8qKi5mdW5jdGlvbmFsLnRlc3QuanMnXSwgY3dkOiB0ZXN0c1Jvb3QgfSwgKGVycm9yLCBmaWxlcykgPT4ge1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiBtb2NoYS5hZGRGaWxlKHBhdGguam9pbih0ZXN0c1Jvb3QsIGZpbGUpKSk7XG4gICAgICAgICAgICBtb2NoYS5ydW4oKGZhaWx1cmVzKSA9PiBjYWxsYmFjayh1bmRlZmluZWQsIGZhaWx1cmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnJ1biA9IHJ1bjtcbmZ1bmN0aW9uIGdldENvdmVyYWdlT3B0aW9ucyh0ZXN0c1Jvb3QpIHtcbiAgICBpZiAoIWNvdmVyYWdlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjb3ZlckNvbmZpZ1BhdGggPSBwYXRoLmpvaW4odGVzdHNSb290LCBjb3ZlcmFnZU9wdGlvbnMuY292ZXJhZ2VDb25maWcpO1xuICAgIHJldHVybiBmcy5leGlzdHNTeW5jKGNvdmVyQ29uZmlnUGF0aCkgPyBKU09OLnBhcnNlKGZzLnJlYWRGaWxlU3luYyhjb3ZlckNvbmZpZ1BhdGgsICd1dGY4JykpIDogdW5kZWZpbmVkO1xufVxuY2xhc3MgQ292ZXJhZ2VSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHRlc3RzUm9vdCwgZW5kUnVuQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy50ZXN0c1Jvb3QgPSB0ZXN0c1Jvb3Q7XG4gICAgICAgIHRoaXMuY292ZXJhZ2VWYXIgPSBgJCRjb3ZfJHtuZXcgRGF0ZSgpLmdldFRpbWUoKX0kJGA7XG4gICAgICAgIHRoaXMuc291cmNlRmlsZXMgPSBbXTtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJlbGF0aXZlU291cmNlUGF0aCkge1xuICAgICAgICAgICAgZW5kUnVuQ2FsbGJhY2sobmV3IEVycm9yKCdFcnJvciAtIHJlbGF0aXZlU291cmNlUGF0aCBtdXN0IGJlIGRlZmluZWQgZm9yIGNvZGUgY292ZXJhZ2UgdG8gd29yaycpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgY292ZXJhZ2UoKSB7XG4gICAgICAgIGlmIChnbG9iYWxbdGhpcy5jb3ZlcmFnZVZhcl0gPT09IHVuZGVmaW5lZCB8fCBPYmplY3Qua2V5cyhnbG9iYWxbdGhpcy5jb3ZlcmFnZVZhcl0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gY292ZXJhZ2UgaW5mb3JtYXRpb24gd2FzIGNvbGxlY3RlZCwgZXhpdCB3aXRob3V0IHdyaXRpbmcgY292ZXJhZ2UgaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxbdGhpcy5jb3ZlcmFnZVZhcl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0IGNvdmVyYWdlKHZhbHVlKSB7XG4gICAgICAgIGdsb2JhbFt0aGlzLmNvdmVyYWdlVmFyXSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmZvcm1hdGlvbiBvbiBob29raW5nIHVwIGNvZGUgY292ZXJhZ2UgY2FuIGJlIGZvdW5kIGhlcmU6XG4gICAgICogaHR0cDovL3Rhbm5ndXllbi5vcmcvMjAxNy8wNC9ndWxwLW1vY2hhLWFuZC1pc3RhbmJ1bC9cbiAgICAgKiBodHRwOi8vZ290d2FybG9zdC5naXRodWIuaW8vaXN0YW5idWwvcHVibGljL2FwaWRvY3MvY2xhc3Nlcy9Ib29rT3B0aW9ucy5odG1sXG4gICAgICogQG1lbWJlcm9mIENvdmVyYWdlUnVubmVyXG4gICAgICovXG4gICAgc2V0dXBDb3ZlcmFnZSgpIHtcbiAgICAgICAgY29uc3QgcmVwb3J0aW5nRGlyID0gcGF0aC5qb2luKHRoaXMudGVzdHNSb290LCB0aGlzLm9wdGlvbnMucmVsYXRpdmVDb3ZlcmFnZURpcik7XG4gICAgICAgIGZzLmVtcHR5RGlyU3luYyhyZXBvcnRpbmdEaXIpO1xuICAgICAgICAvLyBTZXQgdXAgQ29kZSBDb3ZlcmFnZSwgaG9va2luZyByZXF1aXJlIHNvIHRoYXQgaW5zdHJ1bWVudGVkIGNvZGUgaXMgcmV0dXJuZWQuXG4gICAgICAgIHRoaXMuaW5zdHJ1bWVudGVyID0gbmV3IGlzdGFuYnVsLkluc3RydW1lbnRlcih7IGNvdmVyYWdlVmFyaWFibGU6IHRoaXMuY292ZXJhZ2VWYXIgfSk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVJvb3QgPSBwYXRoLmpvaW4odGhpcy50ZXN0c1Jvb3QsIHRoaXMub3B0aW9ucy5yZWxhdGl2ZVNvdXJjZVBhdGgpO1xuICAgICAgICAvLyBHbG9iIHNvdXJjZSBmaWxlc1xuICAgICAgICBjb25zdCBzcmNGaWxlcyA9IGdsb2Iuc3luYygnKiovKiouanMnLCB7XG4gICAgICAgICAgICBpZ25vcmU6IHRoaXMub3B0aW9ucy5pZ25vcmVQYXR0ZXJucyxcbiAgICAgICAgICAgIGN3ZDogc291cmNlUm9vdFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbWF0Y2ggZnVuY3Rpb24gLSB0YWtlbiBmcm9tIHRoZSBydW4td2l0aC1jb3Zlci5qcyBpbiBpc3RhbmJ1bC5cbiAgICAgICAgY29uc3QgZGVjYWNoZSA9IHJlcXVpcmUoJ2RlY2FjaGUnKTtcbiAgICAgICAgY29uc3QgZmlsZU1hcCA9IG5ldyBTZXQoKTtcbiAgICAgICAgc3JjRmlsZXNcbiAgICAgICAgICAgIC5tYXAoZmlsZSA9PiBwYXRoLmpvaW4oc291cmNlUm9vdCwgZmlsZSkpXG4gICAgICAgICAgICAuZm9yRWFjaChmdWxsUGF0aCA9PiB7XG4gICAgICAgICAgICBmaWxlTWFwLmFkZChmdWxsUGF0aCk7XG4gICAgICAgICAgICAvLyBPbiBXaW5kb3dzLCBleHRlbnNpb24gaXMgbG9hZGVkIHByZS10ZXN0IGhvb2tzIGFuZCB0aGlzIG1lYW4gd2UgbG9zZVxuICAgICAgICAgICAgLy8gb3VyIGNoYW5jZSB0byBob29rIHRoZSBSZXF1aXJlIGNhbGwuIEluIG9yZGVyIHRvIGluc3RydW1lbnQgdGhlIGNvZGVcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gZGVjYWNoZSB0aGUgSlMgZmlsZSBzbyBvbiBuZXh0IGxvYWQgaXQgZ2V0cyBpbnN0cnVtZW50ZWQuXG4gICAgICAgICAgICAvLyBUaGlzIGRvZXNuJ3QgaW1wYWN0IHRlc3RzLCBidXQgaXMgYSBjb25jZXJuIGlmIHdlIGhhZCBzb21lIGludGVncmF0aW9uXG4gICAgICAgICAgICAvLyB0ZXN0cyB0aGF0IHJlbGllZCBvbiBWU0NvZGUgYWNjZXNzaW5nIG91ciBtb2R1bGUgc2luY2UgdGhlcmUgY291bGQgYmVcbiAgICAgICAgICAgIC8vIHNvbWUgc2hhcmVkIGdsb2JhbCBzdGF0ZSB0aGF0IHdlIGxvc2UuXG4gICAgICAgICAgICBkZWNhY2hlKGZ1bGxQYXRoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1hdGNoRm4gPSAoZmlsZSkgPT4gZmlsZU1hcC5oYXMoZmlsZSk7XG4gICAgICAgIHRoaXMuc291cmNlRmlsZXMgPSBBcnJheS5mcm9tKGZpbGVNYXAua2V5cygpKTtcbiAgICAgICAgLy8gaHR0cDovL2dvdHdhcmxvc3QuZ2l0aHViLmlvL2lzdGFuYnVsL3B1YmxpYy9hcGlkb2NzL2NsYXNzZXMvSG9vay5odG1sI21ldGhvZF9ob29rUmVxdWlyZS5cbiAgICAgICAgLy8gSG9vayB1cCB0byB0aGUgUmVxdWlyZSBmdW5jdGlvbiBzbyB0aGF0IHdoZW4gdGhpcyBpcyBjYWxsZWQsIGlmIGFueSBvZiBvdXIgc291cmNlIGZpbGVzXG4gICAgICAgIC8vIGFyZSByZXF1aXJlZCwgdGhlIGluc3RydW1lbnRlZCB2ZXJzaW9uIGlzIHB1bGxlZCBpbiBpbnN0ZWFkLiBUaGVzZSBpbnN0cnVtZW50ZWQgdmVyc2lvbnNcbiAgICAgICAgLy8gd3JpdGUgdG8gYSBnbG9iYWwgY292ZXJhZ2UgdmFyaWFibGUgd2l0aCBoaXQgY291bnRzIHdoZW5ldmVyIHRoZXkgYXJlIGFjY2Vzc2VkLlxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHRoaXMuaW5zdHJ1bWVudGVyLmluc3RydW1lbnRTeW5jLmJpbmQodGhpcy5pbnN0cnVtZW50ZXIpO1xuICAgICAgICBjb25zdCBob29rT3B0cyA9IHsgdmVyYm9zZTogZmFsc2UsIGV4dGVuc2lvbnM6IFsnLmpzJ10gfTtcbiAgICAgICAgaXN0YW5idWwuaG9vay5ob29rUmVxdWlyZShtYXRjaEZuLCB0cmFuc2Zvcm1lciwgaG9va09wdHMpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBnbG9iYWwgdmFyaWFibGUgdG8gc3RvcmUgaW5zdHJ1bWVudGF0aW9uIGRldGFpbHMuXG4gICAgICAgIC8vIGh0dHA6Ly9nb3R3YXJsb3N0LmdpdGh1Yi5pby9pc3RhbmJ1bC9wdWJsaWMvYXBpZG9jcy9jbGFzc2VzL0luc3RydW1lbnRlci5odG1sLlxuICAgICAgICB0aGlzLmNvdmVyYWdlID0ge307XG4gICAgICAgIC8vIEhvb2sgdGhlIHByb2Nlc3MgZXhpdCBldmVudCB0byBoYW5kbGUgcmVwb3J0aW5nLFxuICAgICAgICAvLyBPbmx5IHJlcG9ydCBjb3ZlcmFnZSBpZiB0aGUgcHJvY2VzcyBpcyBleGl0aW5nIHN1Y2Nlc3NmdWxseS5cbiAgICAgICAgcHJvY2Vzcy5vbignZXhpdCcsICgpID0+IHRoaXMucmVwb3J0Q292ZXJhZ2UoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIGNvdmVyYWdlIHJlcG9ydC4gTm90ZSB0aGF0IGFzIHRoaXMgaXMgY2FsbGVkIGluIHRoZSBwcm9jZXNzIGV4aXQgY2FsbGJhY2ssIGFsbCBjYWxscyBtdXN0IGJlIHN5bmNocm9ub3VzLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqIEBtZW1iZXJPZiBDb3ZlcmFnZVJ1bm5lclxuICAgICAqL1xuICAgIHJlcG9ydENvdmVyYWdlKCkge1xuICAgICAgICBpc3RhbmJ1bC5ob29rLnVuaG9va1JlcXVpcmUoKTtcbiAgICAgICAgY29uc3QgY292ZXJhZ2UgPSB0aGlzLmNvdmVyYWdlO1xuICAgICAgICAvLyBGaWxlcyB0aGF0IGFyZSBub3QgdG91Y2hlZCBieSBjb2RlIHJhbiBieSB0aGUgdGVzdCBydW5uZXIgaXMgbWFudWFsbHkgaW5zdHJ1bWVudGVkLCB0b1xuICAgICAgICAvLyBpbGx1c3RyYXRlIHRoZSBtaXNzaW5nIGNvdmVyYWdlLlxuICAgICAgICB0aGlzLnNvdXJjZUZpbGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZpbGUgPT4gIWNvdmVyYWdlW2ZpbGVdKVxuICAgICAgICAgICAgLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgICAgICB0aGlzLmluc3RydW1lbnRlci5pbnN0cnVtZW50U3luYyhmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0Zi04JyksIGZpbGUpO1xuICAgICAgICAgICAgLy8gV2hlbiBpbnN0cnVtZW50aW5nIHRoZSBjb2RlLCBpc3RhbmJ1bCB3aWxsIGdpdmUgZWFjaCBGdW5jdGlvbkRlY2xhcmF0aW9uIGEgdmFsdWUgb2YgMSBpbiBjb3ZlclN0YXRlLnMsXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IHRvIGNvbXBlbnNhdGUgZm9yIGZ1bmN0aW9uIGhvaXN0aW5nLiBXZSBuZWVkIHRvIHJlc2V0IHRoaXMsIGFzIHRoZSBmdW5jdGlvbiB3YXMgbm90IGhvaXN0ZWQsXG4gICAgICAgICAgICAvLyBhcyBpdCB3YXMgbmV2ZXIgbG9hZGVkLlxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnN0cnVtZW50ZXIuY292ZXJTdGF0ZS5zKS5mb3JFYWNoKGtleSA9PiB0aGlzLmluc3RydW1lbnRlci5jb3ZlclN0YXRlLnNba2V5XSA9IDApO1xuICAgICAgICAgICAgY292ZXJhZ2VbZmlsZV0gPSB0aGlzLmluc3RydW1lbnRlci5jb3ZlclN0YXRlO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVwb3J0aW5nRGlyID0gcGF0aC5qb2luKHRoaXMudGVzdHNSb290LCB0aGlzLm9wdGlvbnMucmVsYXRpdmVDb3ZlcmFnZURpcik7XG4gICAgICAgIGNvbnN0IGNvdmVyYWdlRmlsZSA9IHBhdGguam9pbihyZXBvcnRpbmdEaXIsICdjb3ZlcmFnZS5qc29uJyk7XG4gICAgICAgIGZzLm1rZGlyc1N5bmMocmVwb3J0aW5nRGlyKTtcbiAgICAgICAgZnMud3JpdGVGaWxlU3luYyhjb3ZlcmFnZUZpbGUsIEpTT04uc3RyaW5naWZ5KGNvdmVyYWdlKSwgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3QgcmVtYXBwZWRDb2xsZWN0b3IgPSByZW1hcElzdGFuYnVsLnJlbWFwKGNvdmVyYWdlLCB7XG4gICAgICAgICAgICB3YXJuOiB3YXJuaW5nID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBleHBlY3Qgc29tZSB3YXJuaW5ncyBhcyBhbnkgSlMgZmlsZSB3aXRob3V0IGEgdHlwZXNjcmlwdCBtYXBwaW5nIHdpbGwgY2F1c2UgdGhpcy5cbiAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCB3ZSdsbCBza2lwIHByaW50aW5nIHRoZXNlIHRvIHRoZSBjb25zb2xlIGFzIGl0IGNsdXR0ZXJzIGl0IHVwLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyYm9zZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVwb3J0ZXIgPSBuZXcgaXN0YW5idWwuUmVwb3J0ZXIodW5kZWZpbmVkLCByZXBvcnRpbmdEaXIpO1xuICAgICAgICBjb25zdCByZXBvcnRUeXBlcyA9IEFycmF5LmlzQXJyYXkodGhpcy5vcHRpb25zLnJlcG9ydHMpID8gdGhpcy5vcHRpb25zLnJlcG9ydHMgOiBbJ2xjb3YnXTtcbiAgICAgICAgcmVwb3J0ZXIuYWRkQWxsKHJlcG9ydFR5cGVzKTtcbiAgICAgICAgcmVwb3J0ZXIud3JpdGUocmVtYXBwZWRDb2xsZWN0b3IsIHRydWUsICgpID0+IGNvbnNvbGUubG9nKGByZXBvcnRzIHdyaXR0ZW4gdG8gJHtyZXBvcnRpbmdEaXJ9YCkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlc3RSdW5uZXIuanMubWFwIl19