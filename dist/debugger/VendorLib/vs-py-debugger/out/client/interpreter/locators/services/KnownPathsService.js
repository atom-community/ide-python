"use strict";

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const inversify_1 = require("inversify");

const _ = require("lodash");

const path = require("path");

const types_1 = require("../../../common/platform/types");

const types_2 = require("../../../common/types");

const fs_1 = require("../../../common/utils/fs");

const types_3 = require("../../../ioc/types");

const contracts_1 = require("../../contracts");

const helpers_1 = require("../helpers");

const cacheableLocatorService_1 = require("./cacheableLocatorService");
/**
 * Locates "known" paths.
 */


let KnownPathsService = class KnownPathsService extends cacheableLocatorService_1.CacheableLocatorService {
  constructor(knownSearchPaths, helper, serviceContainer) {
    super('KnownPathsService', serviceContainer);
    this.knownSearchPaths = knownSearchPaths;
    this.helper = helper;
  }
  /**
   * Release any held resources.
   *
   * Called by VS Code to indicate it is done with the resource.
   */
  // tslint:disable-next-line:no-empty


  dispose() {}
  /**
   * Return the located interpreters.
   *
   * This is used by CacheableLocatorService.getInterpreters().
   */


  getInterpretersImplementation(resource) {
    return this.suggestionsFromKnownPaths();
  }
  /**
   * Return the located interpreters.
   */


  suggestionsFromKnownPaths() {
    const promises = this.knownSearchPaths.getSearchPaths().map(dir => this.getInterpretersInDirectory(dir));
    return Promise.all(promises) // tslint:disable-next-line:underscore-consistent-invocation
    .then(listOfInterpreters => _.flatten(listOfInterpreters)).then(interpreters => interpreters.filter(item => item.length > 0)).then(interpreters => Promise.all(interpreters.map(interpreter => this.getInterpreterDetails(interpreter)))).then(interpreters => interpreters.filter(interpreter => !!interpreter).map(interpreter => interpreter));
  }
  /**
   * Return the information about the identified interpreter binary.
   */


  getInterpreterDetails(interpreter) {
    return __awaiter(this, void 0, void 0, function* () {
      const details = yield this.helper.getInterpreterInformation(interpreter);

      if (!details) {
        return;
      }

      return Object.assign({}, details, {
        path: interpreter,
        type: contracts_1.InterpreterType.Unknown
      });
    });
  }
  /**
   * Return the interpreters in the given directory.
   */


  getInterpretersInDirectory(dir) {
    return fs_1.fsExistsAsync(dir).then(exists => exists ? helpers_1.lookForInterpretersInDirectory(dir) : Promise.resolve([]));
  }

};
KnownPathsService = __decorate([inversify_1.injectable(), __param(0, inversify_1.inject(contracts_1.IKnownSearchPathsForInterpreters)), __param(1, inversify_1.inject(contracts_1.IInterpreterHelper)), __param(2, inversify_1.inject(types_3.IServiceContainer))], KnownPathsService);
exports.KnownPathsService = KnownPathsService;
let KnownSearchPathsForInterpreters = class KnownSearchPathsForInterpreters {
  constructor(serviceContainer) {
    this.serviceContainer = serviceContainer;
  }
  /**
   * Return the paths where Python interpreters might be found.
   */


  getSearchPaths() {
    const currentProcess = this.serviceContainer.get(types_2.ICurrentProcess);
    const platformService = this.serviceContainer.get(types_1.IPlatformService);
    const pathUtils = this.serviceContainer.get(types_2.IPathUtils);
    const searchPaths = currentProcess.env[platformService.pathVariableName].split(pathUtils.delimiter).map(p => p.trim()).filter(p => p.length > 0);

    if (!platformService.isWindows) {
      ['/usr/local/bin', '/usr/bin', '/bin', '/usr/sbin', '/sbin', '/usr/local/sbin'].forEach(p => {
        searchPaths.push(p);
        searchPaths.push(path.join(pathUtils.home, p));
      }); // Add support for paths such as /Users/xxx/anaconda/bin.

      if (process.env.HOME) {
        searchPaths.push(path.join(pathUtils.home, 'anaconda', 'bin'));
        searchPaths.push(path.join(pathUtils.home, 'python', 'bin'));
      }
    }

    return searchPaths;
  }

};
KnownSearchPathsForInterpreters = __decorate([inversify_1.injectable(), __param(0, inversify_1.inject(types_3.IServiceContainer))], KnownSearchPathsForInterpreters);
exports.KnownSearchPathsForInterpreters = KnownSearchPathsForInterpreters;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIktub3duUGF0aHNTZXJ2aWNlLmpzIl0sIm5hbWVzIjpbIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJyIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZCIsIlJlZmxlY3QiLCJkZWNvcmF0ZSIsImkiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fcGFyYW0iLCJwYXJhbUluZGV4IiwiZGVjb3JhdG9yIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsImV4cG9ydHMiLCJpbnZlcnNpZnlfMSIsInJlcXVpcmUiLCJfIiwicGF0aCIsInR5cGVzXzEiLCJ0eXBlc18yIiwiZnNfMSIsInR5cGVzXzMiLCJjb250cmFjdHNfMSIsImhlbHBlcnNfMSIsImNhY2hlYWJsZUxvY2F0b3JTZXJ2aWNlXzEiLCJLbm93blBhdGhzU2VydmljZSIsIkNhY2hlYWJsZUxvY2F0b3JTZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJrbm93blNlYXJjaFBhdGhzIiwiaGVscGVyIiwic2VydmljZUNvbnRhaW5lciIsImRpc3Bvc2UiLCJnZXRJbnRlcnByZXRlcnNJbXBsZW1lbnRhdGlvbiIsInJlc291cmNlIiwic3VnZ2VzdGlvbnNGcm9tS25vd25QYXRocyIsInByb21pc2VzIiwiZ2V0U2VhcmNoUGF0aHMiLCJtYXAiLCJkaXIiLCJnZXRJbnRlcnByZXRlcnNJbkRpcmVjdG9yeSIsImFsbCIsImxpc3RPZkludGVycHJldGVycyIsImZsYXR0ZW4iLCJpbnRlcnByZXRlcnMiLCJmaWx0ZXIiLCJpdGVtIiwiaW50ZXJwcmV0ZXIiLCJnZXRJbnRlcnByZXRlckRldGFpbHMiLCJkZXRhaWxzIiwiZ2V0SW50ZXJwcmV0ZXJJbmZvcm1hdGlvbiIsImFzc2lnbiIsInR5cGUiLCJJbnRlcnByZXRlclR5cGUiLCJVbmtub3duIiwiZnNFeGlzdHNBc3luYyIsImV4aXN0cyIsImxvb2tGb3JJbnRlcnByZXRlcnNJbkRpcmVjdG9yeSIsImluamVjdGFibGUiLCJpbmplY3QiLCJJS25vd25TZWFyY2hQYXRoc0ZvckludGVycHJldGVycyIsIklJbnRlcnByZXRlckhlbHBlciIsIklTZXJ2aWNlQ29udGFpbmVyIiwiS25vd25TZWFyY2hQYXRoc0ZvckludGVycHJldGVycyIsImN1cnJlbnRQcm9jZXNzIiwiZ2V0IiwiSUN1cnJlbnRQcm9jZXNzIiwicGxhdGZvcm1TZXJ2aWNlIiwiSVBsYXRmb3JtU2VydmljZSIsInBhdGhVdGlscyIsIklQYXRoVXRpbHMiLCJzZWFyY2hQYXRocyIsImVudiIsInBhdGhWYXJpYWJsZU5hbWUiLCJzcGxpdCIsImRlbGltaXRlciIsInAiLCJ0cmltIiwiaXNXaW5kb3dzIiwiZm9yRWFjaCIsInB1c2giLCJqb2luIiwiaG9tZSIsInByb2Nlc3MiLCJIT01FIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxVQUFVLEdBQUksVUFBUSxTQUFLQSxVQUFkLElBQTZCLFVBQVVDLFVBQVYsRUFBc0JDLE1BQXRCLEVBQThCQyxHQUE5QixFQUFtQ0MsSUFBbkMsRUFBeUM7QUFDbkYsTUFBSUMsQ0FBQyxHQUFHQyxTQUFTLENBQUNDLE1BQWxCO0FBQUEsTUFBMEJDLENBQUMsR0FBR0gsQ0FBQyxHQUFHLENBQUosR0FBUUgsTUFBUixHQUFpQkUsSUFBSSxLQUFLLElBQVQsR0FBZ0JBLElBQUksR0FBR0ssTUFBTSxDQUFDQyx3QkFBUCxDQUFnQ1IsTUFBaEMsRUFBd0NDLEdBQXhDLENBQXZCLEdBQXNFQyxJQUFySDtBQUFBLE1BQTJITyxDQUEzSDtBQUNBLE1BQUksT0FBT0MsT0FBUCxLQUFtQixRQUFuQixJQUErQixPQUFPQSxPQUFPLENBQUNDLFFB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WixDQUFpQjlELElBQUksQ0FBQytELElBQUwsQ0FBVVosU0FBUyxDQUFDYSxJQUFwQixFQUEwQixRQUExQixFQUFvQyxLQUFwQyxDQUFqQjtBQUNIO0FBQ0o7O0FBQ0QsV0FBT1gsV0FBUDtBQUNIOztBQTVCdUUsQ0FBNUU7QUE4QkFSLCtCQUErQixHQUFHdEYsVUFBVSxDQUFDLENBQ3pDc0MsV0FBVyxDQUFDMkMsVUFBWixFQUR5QyxFQUV6Q2pFLE9BQU8sQ0FBQyxDQUFELEVBQUlzQixXQUFXLENBQUM0QyxNQUFaLENBQW1CckMsT0FBTyxDQUFDd0MsaUJBQTNCLENBQUosQ0FGa0MsQ0FBRCxFQUd6Q0MsK0JBSHlDLENBQTVDO0FBSUFqRCxPQUFPLENBQUNpRCwrQkFBUixHQUEwQ0EsK0JBQTFDIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaW52ZXJzaWZ5XzEgPSByZXF1aXJlKFwiaW52ZXJzaWZ5XCIpO1xuY29uc3QgXyA9IHJlcXVpcmUoXCJsb2Rhc2hcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbW1vbi9wbGF0Zm9ybS90eXBlc1wiKTtcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29tbW9uL3R5cGVzXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb21tb24vdXRpbHMvZnNcIik7XG5jb25zdCB0eXBlc18zID0gcmVxdWlyZShcIi4uLy4uLy4uL2lvYy90eXBlc1wiKTtcbmNvbnN0IGNvbnRyYWN0c18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnRyYWN0c1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzXCIpO1xuY29uc3QgY2FjaGVhYmxlTG9jYXRvclNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2NhY2hlYWJsZUxvY2F0b3JTZXJ2aWNlXCIpO1xuLyoqXG4gKiBMb2NhdGVzIFwia25vd25cIiBwYXRocy5cbiAqL1xubGV0IEtub3duUGF0aHNTZXJ2aWNlID0gY2xhc3MgS25vd25QYXRoc1NlcnZpY2UgZXh0ZW5kcyBjYWNoZWFibGVMb2NhdG9yU2VydmljZV8xLkNhY2hlYWJsZUxvY2F0b3JTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcihrbm93blNlYXJjaFBhdGhzLCBoZWxwZXIsIHNlcnZpY2VDb250YWluZXIpIHtcbiAgICAgICAgc3VwZXIoJ0tub3duUGF0aHNTZXJ2aWNlJywgc2VydmljZUNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMua25vd25TZWFyY2hQYXRocyA9IGtub3duU2VhcmNoUGF0aHM7XG4gICAgICAgIHRoaXMuaGVscGVyID0gaGVscGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWxlYXNlIGFueSBoZWxkIHJlc291cmNlcy5cbiAgICAgKlxuICAgICAqIENhbGxlZCBieSBWUyBDb2RlIHRvIGluZGljYXRlIGl0IGlzIGRvbmUgd2l0aCB0aGUgcmVzb3VyY2UuXG4gICAgICovXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWVtcHR5XG4gICAgZGlzcG9zZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgbG9jYXRlZCBpbnRlcnByZXRlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHVzZWQgYnkgQ2FjaGVhYmxlTG9jYXRvclNlcnZpY2UuZ2V0SW50ZXJwcmV0ZXJzKCkuXG4gICAgICovXG4gICAgZ2V0SW50ZXJwcmV0ZXJzSW1wbGVtZW50YXRpb24ocmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VnZ2VzdGlvbnNGcm9tS25vd25QYXRocygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxvY2F0ZWQgaW50ZXJwcmV0ZXJzLlxuICAgICAqL1xuICAgIHN1Z2dlc3Rpb25zRnJvbUtub3duUGF0aHMoKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5rbm93blNlYXJjaFBhdGhzLmdldFNlYXJjaFBhdGhzKCkubWFwKGRpciA9PiB0aGlzLmdldEludGVycHJldGVyc0luRGlyZWN0b3J5KGRpcikpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dW5kZXJzY29yZS1jb25zaXN0ZW50LWludm9jYXRpb25cbiAgICAgICAgICAgIC50aGVuKGxpc3RPZkludGVycHJldGVycyA9PiBfLmZsYXR0ZW4obGlzdE9mSW50ZXJwcmV0ZXJzKSlcbiAgICAgICAgICAgIC50aGVuKGludGVycHJldGVycyA9PiBpbnRlcnByZXRlcnMuZmlsdGVyKGl0ZW0gPT4gaXRlbS5sZW5ndGggPiAwKSlcbiAgICAgICAgICAgIC50aGVuKGludGVycHJldGVycyA9PiBQcm9taXNlLmFsbChpbnRlcnByZXRlcnMubWFwKGludGVycHJldGVyID0+IHRoaXMuZ2V0SW50ZXJwcmV0ZXJEZXRhaWxzKGludGVycHJldGVyKSkpKVxuICAgICAgICAgICAgLnRoZW4oaW50ZXJwcmV0ZXJzID0+IGludGVycHJldGVycy5maWx0ZXIoaW50ZXJwcmV0ZXIgPT4gISFpbnRlcnByZXRlcikubWFwKGludGVycHJldGVyID0+IGludGVycHJldGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGlkZW50aWZpZWQgaW50ZXJwcmV0ZXIgYmluYXJ5LlxuICAgICAqL1xuICAgIGdldEludGVycHJldGVyRGV0YWlscyhpbnRlcnByZXRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IHlpZWxkIHRoaXMuaGVscGVyLmdldEludGVycHJldGVySW5mb3JtYXRpb24oaW50ZXJwcmV0ZXIpO1xuICAgICAgICAgICAgaWYgKCFkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRldGFpbHMsIHsgcGF0aDogaW50ZXJwcmV0ZXIsIHR5cGU6IGNvbnRyYWN0c18xLkludGVycHJldGVyVHlwZS5Vbmtub3duIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBpbnRlcnByZXRlcnMgaW4gdGhlIGdpdmVuIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICBnZXRJbnRlcnByZXRlcnNJbkRpcmVjdG9yeShkaXIpIHtcbiAgICAgICAgcmV0dXJuIGZzXzEuZnNFeGlzdHNBc3luYyhkaXIpXG4gICAgICAgICAgICAudGhlbihleGlzdHMgPT4gZXhpc3RzID8gaGVscGVyc18xLmxvb2tGb3JJbnRlcnByZXRlcnNJbkRpcmVjdG9yeShkaXIpIDogUHJvbWlzZS5yZXNvbHZlKFtdKSk7XG4gICAgfVxufTtcbktub3duUGF0aHNTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgaW52ZXJzaWZ5XzEuaW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0oMCwgaW52ZXJzaWZ5XzEuaW5qZWN0KGNvbnRyYWN0c18xLklLbm93blNlYXJjaFBhdGhzRm9ySW50ZXJwcmV0ZXJzKSksXG4gICAgX19wYXJhbSgxLCBpbnZlcnNpZnlfMS5pbmplY3QoY29udHJhY3RzXzEuSUludGVycHJldGVySGVscGVyKSksXG4gICAgX19wYXJhbSgyLCBpbnZlcnNpZnlfMS5pbmplY3QodHlwZXNfMy5JU2VydmljZUNvbnRhaW5lcikpXG5dLCBLbm93blBhdGhzU2VydmljZSk7XG5leHBvcnRzLktub3duUGF0aHNTZXJ2aWNlID0gS25vd25QYXRoc1NlcnZpY2U7XG5sZXQgS25vd25TZWFyY2hQYXRoc0ZvckludGVycHJldGVycyA9IGNsYXNzIEtub3duU2VhcmNoUGF0aHNGb3JJbnRlcnByZXRlcnMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VDb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5zZXJ2aWNlQ29udGFpbmVyID0gc2VydmljZUNvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwYXRocyB3aGVyZSBQeXRob24gaW50ZXJwcmV0ZXJzIG1pZ2h0IGJlIGZvdW5kLlxuICAgICAqL1xuICAgIGdldFNlYXJjaFBhdGhzKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50UHJvY2VzcyA9IHRoaXMuc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMi5JQ3VycmVudFByb2Nlc3MpO1xuICAgICAgICBjb25zdCBwbGF0Zm9ybVNlcnZpY2UgPSB0aGlzLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSVBsYXRmb3JtU2VydmljZSk7XG4gICAgICAgIGNvbnN0IHBhdGhVdGlscyA9IHRoaXMuc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMi5JUGF0aFV0aWxzKTtcbiAgICAgICAgY29uc3Qgc2VhcmNoUGF0aHMgPSBjdXJyZW50UHJvY2Vzcy5lbnZbcGxhdGZvcm1TZXJ2aWNlLnBhdGhWYXJpYWJsZU5hbWVdXG4gICAgICAgICAgICAuc3BsaXQocGF0aFV0aWxzLmRlbGltaXRlcilcbiAgICAgICAgICAgIC5tYXAocCA9PiBwLnRyaW0oKSlcbiAgICAgICAgICAgIC5maWx0ZXIocCA9PiBwLmxlbmd0aCA+IDApO1xuICAgICAgICBpZiAoIXBsYXRmb3JtU2VydmljZS5pc1dpbmRvd3MpIHtcbiAgICAgICAgICAgIFsnL3Vzci9sb2NhbC9iaW4nLCAnL3Vzci9iaW4nLCAnL2JpbicsICcvdXNyL3NiaW4nLCAnL3NiaW4nLCAnL3Vzci9sb2NhbC9zYmluJ11cbiAgICAgICAgICAgICAgICAuZm9yRWFjaChwID0+IHtcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXRocy5wdXNoKHApO1xuICAgICAgICAgICAgICAgIHNlYXJjaFBhdGhzLnB1c2gocGF0aC5qb2luKHBhdGhVdGlscy5ob21lLCBwKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFkZCBzdXBwb3J0IGZvciBwYXRocyBzdWNoIGFzIC9Vc2Vycy94eHgvYW5hY29uZGEvYmluLlxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52LkhPTUUpIHtcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXRocy5wdXNoKHBhdGguam9pbihwYXRoVXRpbHMuaG9tZSwgJ2FuYWNvbmRhJywgJ2JpbicpKTtcbiAgICAgICAgICAgICAgICBzZWFyY2hQYXRocy5wdXNoKHBhdGguam9pbihwYXRoVXRpbHMuaG9tZSwgJ3B5dGhvbicsICdiaW4nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaFBhdGhzO1xuICAgIH1cbn07XG5Lbm93blNlYXJjaFBhdGhzRm9ySW50ZXJwcmV0ZXJzID0gX19kZWNvcmF0ZShbXG4gICAgaW52ZXJzaWZ5XzEuaW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0oMCwgaW52ZXJzaWZ5XzEuaW5qZWN0KHR5cGVzXzMuSVNlcnZpY2VDb250YWluZXIpKVxuXSwgS25vd25TZWFyY2hQYXRoc0ZvckludGVycHJldGVycyk7XG5leHBvcnRzLktub3duU2VhcmNoUGF0aHNGb3JJbnRlcnByZXRlcnMgPSBLbm93blNlYXJjaFBhdGhzRm9ySW50ZXJwcmV0ZXJzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9S25vd25QYXRoc1NlcnZpY2UuanMubWFwIl19