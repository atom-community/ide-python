"use strict";

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __param = void 0 && (void 0).__param || function (paramIndex, decorator) {
  return function (target, key) {
    decorator(target, key, paramIndex);
  };
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const inversify_1 = require("inversify");

const path = require("path");

const types_1 = require("../../../common/platform/types");

const types_2 = require("../../../common/types");

const types_3 = require("../../../ioc/types");

const contracts_1 = require("../../contracts");

const cacheableLocatorService_1 = require("./cacheableLocatorService");

const conda_1 = require("./conda");
/**
 * Locate conda env interpreters based on the "conda environments file".
 */


let CondaEnvFileService = class CondaEnvFileService extends cacheableLocatorService_1.CacheableLocatorService {
  constructor(helperService, condaService, fileSystem, serviceContainer, logger) {
    super('CondaEnvFileService', serviceContainer);
    this.helperService = helperService;
    this.condaService = condaService;
    this.fileSystem = fileSystem;
    this.logger = logger;
  }
  /**
   * Release any held resources.
   *
   * Called by VS Code to indicate it is done with the resource.
   */
  // tslint:disable-next-line:no-empty


  dispose() {}
  /**
   * Return the located interpreters.
   *
   * This is used by CacheableLocatorService.getInterpreters().
   */


  getInterpretersImplementation(resource) {
    return this.getSuggestionsFromConda();
  }
  /**
   * Return the list of interpreters identified by the "conda environments file".
   */


  getSuggestionsFromConda() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.condaService.condaEnvironmentsFile) {
        return [];
      }

      return this.fileSystem.fileExists(this.condaService.condaEnvironmentsFile).then(exists => exists ? this.getEnvironmentsFromFile(this.condaService.condaEnvironmentsFile) : Promise.resolve([]));
    });
  }
  /**
   * Return the list of environments identified in the given file.
   */


  getEnvironmentsFromFile(envFile) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const fileContents = yield this.fileSystem.readFile(envFile);
        const environmentPaths = fileContents.split(/\r?\n/g).map(environmentPath => environmentPath.trim()).filter(environmentPath => environmentPath.length > 0);
        const interpreters = (yield Promise.all(environmentPaths.map(environmentPath => this.getInterpreterDetails(environmentPath)))).filter(item => !!item).map(item => item);
        const environments = yield this.condaService.getCondaEnvironments(true);

        if (Array.isArray(environments) && environments.length > 0) {
          interpreters.forEach(interpreter => {
            const environment = environments.find(item => this.fileSystem.arePathsSame(item.path, interpreter.envPath));

            if (environment) {
              interpreter.envName = environment.name;
            }
          });
        }

        return interpreters;
      } catch (err) {
        this.logger.logError('Python Extension (getEnvironmentsFromFile.readFile):', err); // Ignore errors in reading the file.

        return [];
      }
    });
  }
  /**
   * Return the interpreter info for the given anaconda environment.
   */


  getInterpreterDetails(environmentPath) {
    return __awaiter(this, void 0, void 0, function* () {
      const interpreter = this.condaService.getInterpreterPath(environmentPath);

      if (!interpreter || !(yield this.fileSystem.fileExists(interpreter))) {
        return;
      }

      const details = yield this.helperService.getInterpreterInformation(interpreter);

      if (!details) {
        return;
      }

      const envName = details.envName ? details.envName : path.basename(environmentPath);
      return Object.assign({}, details, {
        path: interpreter,
        companyDisplayName: conda_1.AnacondaCompanyName,
        type: contracts_1.InterpreterType.Conda,
        envPath: environmentPath,
        envName
      });
    });
  }

};
CondaEnvFileService = __decorate([inversify_1.injectable(), __param(0, inversify_1.inject(contracts_1.IInterpreterHelper)), __param(1, inversify_1.inject(contracts_1.ICondaService)), __param(2, inversify_1.inject(types_1.IFileSystem)), __param(3, inversify_1.inject(types_3.IServiceContainer)), __param(4, inversify_1.inject(types_2.ILogger))], CondaEnvFileService);
exports.CondaEnvFileService = CondaEnvFileService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvbmRhRW52RmlsZVNlcnZpY2UuanMiXSwibmFtZXMiOlsiX19kZWNvcmF0ZSIsImRlY29yYXRvcnMiLCJ0YXJnZXQiLCJrZXkiLCJkZXNjIiwiYyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInIiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkIiwiUmVmbGVjdCIsImRlY29yYXRlIiwiaSIsImRlZmluZVByb3BlcnR5IiwiX19wYXJhbSIsInBhcmFtSW5kZXgiLCJkZWNvcmF0b3IiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInZhbHVlIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiZXhwb3J0cyIsImludmVyc2lmeV8xIiwicmVxdWlyZSIsInBhdGgiLCJ0eXBlc18xIiwidHlwZXNfMiIsInR5cGVzXzMiLCJjb250cmFjdHNfMSIsImNhY2hlYWJsZUxvY2F0b3JTZXJ2aWNlXzEiLCJjb25kYV8xIiwiQ29uZGFFbnZGaWxlU2VydmljZSIsIkNhY2hlYWJsZUxvY2F0b3JTZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJoZWxwZXJTZXJ2aWNlIiwiY29uZGFTZXJ2aWNlIiwiZmlsZVN5c3RlbSIsInNlcnZpY2VDb250YWluZXIiLCJsb2dnZXIiLCJkaXNwb3NlIiwiZ2V0SW50ZXJwcmV0ZXJzSW1wbGVtZW50YXRpb24iLCJyZXNvdXJjZSIsImdldFN1Z2dlc3Rpb25zRnJvbUNvbmRhIiwiY29uZGFFbnZpcm9ubWVudHNGaWxlIiwiZmlsZUV4aXN0cyIsImV4aXN0cyIsImdldEVudmlyb25tZW50c0Zyb21GaWxlIiwiZW52RmlsZSIsImZpbGVDb250ZW50cyIsInJlYWRGaWxlIiwiZW52aXJvbm1lbnRQYXRocyIsInNwbGl0IiwibWFwIiwiZW52aXJvbm1lbnRQYXRoIiwidHJpbSIsImZpbHRlciIsImludGVycHJldGVycyIsImFsbCIsImdldEludGVycHJldGVyRGV0YWlscyIsIml0ZW0iLCJlbnZpcm9ubWVudHMiLCJnZXRDb25kYUVudmlyb25tZW50cyIsIkFycmF5IiwiaXNBcnJheSIsImZvckVhY2giLCJpbnRlcnByZXRlciIsImVudmlyb25tZW50IiwiZmluZCIsImFyZVBhdGhzU2FtZSIsImVudlBhdGgiLCJlbnZOYW1lIiwibmFtZSIsImVyciIsImxvZ0Vycm9yIiwiZ2V0SW50ZXJwcmV0ZXJQYXRoIiwiZGV0YWlscyIsImdldEludGVycHJldGVySW5mb3JtYXRpb24iLCJiYXNlbmFtZSIsImFzc2lnbiIsImNvbXBhbnlEaXNwbGF5TmFtZSIsIkFuYWNvbmRhQ29tcGFueU5hbWUiLCJ0eXBlIiwiSW50ZXJwcmV0ZXJUeXBlIiwiQ29uZGEiLCJpbmplY3RhYmxlIiwiaW5qZWN0IiwiSUludGVycHJldGVySGVscGVyIiwiSUNvbmRhU2VydmljZSIsIklGaWxlU3lzdGVtIiwiSVNlcnZpY2VDb250YWluZXIiLCJJTG9nZ2VyIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxVQUFVLEdBQUksVUFBUSxTQUFLQSxVQUFkLElBQTZCLFVBQVVDLFVBQVYsRUFBc0JDLE1BQXRCLEVBQThCQyxHQUE5QixFQUFtQ0MsSUFBbkMsRUFBeUM7QUFDbkYsTUFBSUMsQ0FBQyxHQUFHQyxTQUFTLENBQUNDLE1BQWxCO0FBQUEsTUFBMEJDLENBQUMsR0FBR0gsQ0FBQyxHQUFHLENBQUosR0FBUUgsTUFBUixHQUFpQkUsSUFBSSxLQUFLLElBQVQsR0FBZ0JBLElBQUksR0FBR0ssTUFBTSxDQUFDQyx3QkFBUCxDQUFnQ1IsTUFBaEMsRUFBd0NDLEdBQXhDLENBQXZCLEdBQXNFQyxJQUFySDtBQUFBLE1BQTJITyxDQUEzSDtBQUNBLE1BQUksT0FBT0MsT0FBUCxLQUFtQixRQUFuQixJQUErQixPQUFPQSxPQUFPLENBQUNDLFFBQWYsS0FBNEIsVUFBL0QsRUFBMkVM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QUEzQixDQUFKLENBTHNCLEVBTTdCekYsT0FBTyxDQUFDLENBQUQsRUFBSXNCLFdBQVcsQ0FBQytELE1BQVosQ0FBbUIzRCxPQUFPLENBQUNnRSxPQUEzQixDQUFKLENBTnNCLENBQUQsRUFPN0IzRCxtQkFQNkIsQ0FBaEM7QUFRQVYsT0FBTyxDQUFDVSxtQkFBUixHQUE4QkEsbUJBQTlCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19wYXJhbSA9ICh0aGlzICYmIHRoaXMuX19wYXJhbSkgfHwgZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgaW52ZXJzaWZ5XzEgPSByZXF1aXJlKFwiaW52ZXJzaWZ5XCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb21tb24vcGxhdGZvcm0vdHlwZXNcIik7XG5jb25zdCB0eXBlc18yID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbW1vbi90eXBlc1wiKTtcbmNvbnN0IHR5cGVzXzMgPSByZXF1aXJlKFwiLi4vLi4vLi4vaW9jL3R5cGVzXCIpO1xuY29uc3QgY29udHJhY3RzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29udHJhY3RzXCIpO1xuY29uc3QgY2FjaGVhYmxlTG9jYXRvclNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL2NhY2hlYWJsZUxvY2F0b3JTZXJ2aWNlXCIpO1xuY29uc3QgY29uZGFfMSA9IHJlcXVpcmUoXCIuL2NvbmRhXCIpO1xuLyoqXG4gKiBMb2NhdGUgY29uZGEgZW52IGludGVycHJldGVycyBiYXNlZCBvbiB0aGUgXCJjb25kYSBlbnZpcm9ubWVudHMgZmlsZVwiLlxuICovXG5sZXQgQ29uZGFFbnZGaWxlU2VydmljZSA9IGNsYXNzIENvbmRhRW52RmlsZVNlcnZpY2UgZXh0ZW5kcyBjYWNoZWFibGVMb2NhdG9yU2VydmljZV8xLkNhY2hlYWJsZUxvY2F0b3JTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihoZWxwZXJTZXJ2aWNlLCBjb25kYVNlcnZpY2UsIGZpbGVTeXN0ZW0sIHNlcnZpY2VDb250YWluZXIsIGxvZ2dlcikge1xuICAgICAgICBzdXBlcignQ29uZGFFbnZGaWxlU2VydmljZScsIHNlcnZpY2VDb250YWluZXIpO1xuICAgICAgICB0aGlzLmhlbHBlclNlcnZpY2UgPSBoZWxwZXJTZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbmRhU2VydmljZSA9IGNvbmRhU2VydmljZTtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtID0gZmlsZVN5c3RlbTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbGVhc2UgYW55IGhlbGQgcmVzb3VyY2VzLlxuICAgICAqXG4gICAgICogQ2FsbGVkIGJ5IFZTIENvZGUgdG8gaW5kaWNhdGUgaXQgaXMgZG9uZSB3aXRoIHRoZSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcbiAgICBkaXNwb3NlKCkgeyB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsb2NhdGVkIGludGVycHJldGVycy5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSBDYWNoZWFibGVMb2NhdG9yU2VydmljZS5nZXRJbnRlcnByZXRlcnMoKS5cbiAgICAgKi9cbiAgICBnZXRJbnRlcnByZXRlcnNJbXBsZW1lbnRhdGlvbihyZXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdWdnZXN0aW9uc0Zyb21Db25kYSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2YgaW50ZXJwcmV0ZXJzIGlkZW50aWZpZWQgYnkgdGhlIFwiY29uZGEgZW52aXJvbm1lbnRzIGZpbGVcIi5cbiAgICAgKi9cbiAgICBnZXRTdWdnZXN0aW9uc0Zyb21Db25kYSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25kYVNlcnZpY2UuY29uZGFFbnZpcm9ubWVudHNGaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsZVN5c3RlbS5maWxlRXhpc3RzKHRoaXMuY29uZGFTZXJ2aWNlLmNvbmRhRW52aXJvbm1lbnRzRmlsZSlcbiAgICAgICAgICAgICAgICAudGhlbihleGlzdHMgPT4gZXhpc3RzID8gdGhpcy5nZXRFbnZpcm9ubWVudHNGcm9tRmlsZSh0aGlzLmNvbmRhU2VydmljZS5jb25kYUVudmlyb25tZW50c0ZpbGUpIDogUHJvbWlzZS5yZXNvbHZlKFtdKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2YgZW52aXJvbm1lbnRzIGlkZW50aWZpZWQgaW4gdGhlIGdpdmVuIGZpbGUuXG4gICAgICovXG4gICAgZ2V0RW52aXJvbm1lbnRzRnJvbUZpbGUoZW52RmlsZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlQ29udGVudHMgPSB5aWVsZCB0aGlzLmZpbGVTeXN0ZW0ucmVhZEZpbGUoZW52RmlsZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW52aXJvbm1lbnRQYXRocyA9IGZpbGVDb250ZW50cy5zcGxpdCgvXFxyP1xcbi9nKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGVudmlyb25tZW50UGF0aCA9PiBlbnZpcm9ubWVudFBhdGgudHJpbSgpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGVudmlyb25tZW50UGF0aCA9PiBlbnZpcm9ubWVudFBhdGgubGVuZ3RoID4gMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJwcmV0ZXJzID0gKHlpZWxkIFByb21pc2UuYWxsKGVudmlyb25tZW50UGF0aHNcbiAgICAgICAgICAgICAgICAgICAgLm1hcChlbnZpcm9ubWVudFBhdGggPT4gdGhpcy5nZXRJbnRlcnByZXRlckRldGFpbHMoZW52aXJvbm1lbnRQYXRoKSkpKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGl0ZW0gPT4gaXRlbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW52aXJvbm1lbnRzID0geWllbGQgdGhpcy5jb25kYVNlcnZpY2UuZ2V0Q29uZGFFbnZpcm9ubWVudHModHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZW52aXJvbm1lbnRzKSAmJiBlbnZpcm9ubWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnRlcnByZXRlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKGludGVycHJldGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudmlyb25tZW50ID0gZW52aXJvbm1lbnRzLmZpbmQoaXRlbSA9PiB0aGlzLmZpbGVTeXN0ZW0uYXJlUGF0aHNTYW1lKGl0ZW0ucGF0aCwgaW50ZXJwcmV0ZXIuZW52UGF0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwcmV0ZXIuZW52TmFtZSA9IGVudmlyb25tZW50Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwcmV0ZXJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKCdQeXRob24gRXh0ZW5zaW9uIChnZXRFbnZpcm9ubWVudHNGcm9tRmlsZS5yZWFkRmlsZSk6JywgZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JzIGluIHJlYWRpbmcgdGhlIGZpbGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBpbnRlcnByZXRlciBpbmZvIGZvciB0aGUgZ2l2ZW4gYW5hY29uZGEgZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgZ2V0SW50ZXJwcmV0ZXJEZXRhaWxzKGVudmlyb25tZW50UGF0aCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwcmV0ZXIgPSB0aGlzLmNvbmRhU2VydmljZS5nZXRJbnRlcnByZXRlclBhdGgoZW52aXJvbm1lbnRQYXRoKTtcbiAgICAgICAgICAgIGlmICghaW50ZXJwcmV0ZXIgfHwgISh5aWVsZCB0aGlzLmZpbGVTeXN0ZW0uZmlsZUV4aXN0cyhpbnRlcnByZXRlcikpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGV0YWlscyA9IHlpZWxkIHRoaXMuaGVscGVyU2VydmljZS5nZXRJbnRlcnByZXRlckluZm9ybWF0aW9uKGludGVycHJldGVyKTtcbiAgICAgICAgICAgIGlmICghZGV0YWlscykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudk5hbWUgPSBkZXRhaWxzLmVudk5hbWUgPyBkZXRhaWxzLmVudk5hbWUgOiBwYXRoLmJhc2VuYW1lKGVudmlyb25tZW50UGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZGV0YWlscywgeyBwYXRoOiBpbnRlcnByZXRlciwgY29tcGFueURpc3BsYXlOYW1lOiBjb25kYV8xLkFuYWNvbmRhQ29tcGFueU5hbWUsIHR5cGU6IGNvbnRyYWN0c18xLkludGVycHJldGVyVHlwZS5Db25kYSwgZW52UGF0aDogZW52aXJvbm1lbnRQYXRoLCBlbnZOYW1lIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuQ29uZGFFbnZGaWxlU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIGludmVyc2lmeV8xLmluamVjdGFibGUoKSxcbiAgICBfX3BhcmFtKDAsIGludmVyc2lmeV8xLmluamVjdChjb250cmFjdHNfMS5JSW50ZXJwcmV0ZXJIZWxwZXIpKSxcbiAgICBfX3BhcmFtKDEsIGludmVyc2lmeV8xLmluamVjdChjb250cmFjdHNfMS5JQ29uZGFTZXJ2aWNlKSksXG4gICAgX19wYXJhbSgyLCBpbnZlcnNpZnlfMS5pbmplY3QodHlwZXNfMS5JRmlsZVN5c3RlbSkpLFxuICAgIF9fcGFyYW0oMywgaW52ZXJzaWZ5XzEuaW5qZWN0KHR5cGVzXzMuSVNlcnZpY2VDb250YWluZXIpKSxcbiAgICBfX3BhcmFtKDQsIGludmVyc2lmeV8xLmluamVjdCh0eXBlc18yLklMb2dnZXIpKVxuXSwgQ29uZGFFbnZGaWxlU2VydmljZSk7XG5leHBvcnRzLkNvbmRhRW52RmlsZVNlcnZpY2UgPSBDb25kYUVudkZpbGVTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uZGFFbnZGaWxlU2VydmljZS5qcy5tYXAiXX0=