"use strict"; // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const timers_1 = require("timers");

const types_1 = require("../common/application/types");

const types_2 = require("../common/types");

const autoPep8Formatter_1 = require("./../formatters/autoPep8Formatter");

const blackFormatter_1 = require("./../formatters/blackFormatter");

const dummyFormatter_1 = require("./../formatters/dummyFormatter");

const yapfFormatter_1 = require("./../formatters/yapfFormatter");

class PythonFormattingEditProvider {
  constructor(context, serviceContainer) {
    this.formatters = new Map();
    this.disposables = []; // Workaround for https://github.com/Microsoft/vscode/issues/41194

    this.documentVersionBeforeFormatting = -1;
    this.formatterMadeChanges = false;
    this.saving = false;
    const yapfFormatter = new yapfFormatter_1.YapfFormatter(serviceContainer);
    const autoPep8 = new autoPep8Formatter_1.AutoPep8Formatter(serviceContainer);
    const black = new blackFormatter_1.BlackFormatter(serviceContainer);
    const dummy = new dummyFormatter_1.DummyFormatter(serviceContainer);
    this.formatters.set(yapfFormatter.Id, yapfFormatter);
    this.formatters.set(black.Id, black);
    this.formatters.set(autoPep8.Id, autoPep8);
    this.formatters.set(dummy.Id, dummy);
    this.commands = serviceContainer.get(types_1.ICommandManager);
    this.workspace = serviceContainer.get(types_1.IWorkspaceService);
    this.documentManager = serviceContainer.get(types_1.IDocumentManager);
    this.config = serviceContainer.get(types_2.IConfigurationService);
    this.disposables.push(this.documentManager.onDidSaveTextDocument(document => __awaiter(this, void 0, void 0, function* () {
      return this.onSaveDocument(document);
    })));
  }

  dispose() {
    this.disposables.forEach(d => d.dispose());
  }

  provideDocumentFormattingEdits(document, options, token) {
    return this.provideDocumentRangeFormattingEdits(document, undefined, options, token);
  }

  provideDocumentRangeFormattingEdits(document, range, options, token) {
    return __awaiter(this, void 0, void 0, function* () {
      // Workaround for https://github.com/Microsoft/vscode/issues/41194
      // VSC rejects 'format on save' promise in 750 ms. Python formatting may take quite a bit longer.
      // Workaround is to resolve promise to nothing here, then execute format document and force new save.
      // However, we need to know if this is 'format document' or formatting on save.
      if (this.saving) {
        // We are saving after formatting (see onSaveDocument below)
        // so we do not want to format again.
        return [];
      } // Remember content before formatting so we can detect if
      // formatting edits have been really applied


      const editorConfig = this.workspace.getConfiguration('editor', document.uri);

      if (editorConfig.get('formatOnSave') === true) {
        this.documentVersionBeforeFormatting = document.version;
      }

      const settings = this.config.getSettings(document.uri);
      const formatter = this.formatters.get(settings.formatting.provider);
      const edits = yield formatter.formatDocument(document, options, token, range);
      this.formatterMadeChanges = edits.length > 0;
      return edits;
    });
  }

  onSaveDocument(document) {
    return __awaiter(this, void 0, void 0, function* () {
      // Promise was rejected = formatting took too long.
      // Don't format inside the event handler, do it on timeout
      timers_1.setTimeout(() => {
        try {
          if (this.formatterMadeChanges && !document.isDirty && document.version === this.documentVersionBeforeFormatting) {
            // Formatter changes were not actually applied due to the timeout on save.
            // Force formatting now and then save the document.
            this.commands.executeCommand('editor.action.formatDocument').then(() => __awaiter(this, void 0, void 0, function* () {
              this.saving = true;
              yield document.save();
              this.saving = false;
            }));
          }
        } finally {
          this.documentVersionBeforeFormatting = -1;
          this.saving = false;
          this.formatterMadeChanges = false;
        }
      }, 50);
    });
  }

}

exports.PythonFormattingEditProvider = PythonFormattingEditProvider;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZvcm1hdFByb3ZpZGVyLmpzIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ0aW1lcnNfMSIsInJlcXVpcmUiLCJ0eXBlc18xIiwidHlwZXNfMiIsImF1dG9QZXA4Rm9ybWF0dGVyXzEiLCJibGFja0Zvcm1hdHRlcl8xIiwiZHVtbXlGb3JtYXR0ZXJfMSIsInlhcGZGb3JtYXR0ZXJfMSIsIlB5dGhvbkZvcm1hdHRpbmdFZGl0UHJvdmlkZXIiLCJjb25zdHJ1Y3RvciIsImNvbnRleHQiLCJzZXJ2aWNlQ29udGFpbmVyIiwiZm9ybWF0dGVycyIsIk1hcCIsImRpc3Bvc2FibGVzIiwiZG9jdW1lbnRWZXJzaW9uQmVmb3JlRm9ybWF0dGluZyIsImZvcm1hdHRlck1hZGVDaGFuZ2VzIiwic2F2aW5nIiwieWFwZkZvcm1hdHRlciIsIllhcGZGb3JtYXR0ZXIiLCJhdXRvUGVwOCIsIkF1dG9QZXA4Rm9ybWF0dGVyIiwiYmxhY2siLCJCbGFja0Zvcm1hdHRlciIsImR1bW15IiwiRHVtbXlGb3JtYXR0ZXIiLCJzZXQiLCJJZCIsImNvbW1hbmRzIiwiZ2V0IiwiSUNvbW1hbmRNYW5hZ2VyIiwid29ya3NwYWNlIiwiSVdvcmtzcGFjZVNlcnZpY2UiLCJkb2N1bWVudE1hbmFnZXIiLCJJRG9jdW1lbnRNYW5hZ2VyIiwiY29uZmlnIiwiSUNvbmZpZ3VyYXRpb25TZXJ2aWNlIiwicHVzaCIsIm9uRGlkU2F2ZVRleHREb2N1bWVudCIsImRvY3VtZW50Iiwib25TYXZlRG9jdW1lbnQiLCJkaXNwb3NlIiwiZm9yRWFjaCIsImQiLCJwcm92aWRlRG9jdW1lbnRGb3JtYXR0aW5nRWRpdHMiLCJvcHRpb25zIiwidG9rZW4iLCJwcm92aWRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0cyIsInVuZGVmaW5lZCIsInJhbmdlIiwiZWRpdG9yQ29uZmlnIiwiZ2V0Q29uZmlndXJhdGlvbiIsInVyaSIsInZlcnNpb24iLCJzZXR0aW5ncyIsImdldFNldHRpbmdzIiwiZm9ybWF0dGVyIiwiZm9ybWF0dGluZyIsInByb3ZpZGVyIiwiZWRpdHMiLCJmb3JtYXREb2N1bWVudCIsImxlbmd0aCIsInNldFRpbWVvdXQiLCJpc0RpcnR5IiwiZXhlY3V0ZUNvbW1hbmQiLCJzYXZlIl0sIm1hcHBpbmdzIjoiQUFBQSxhLENBQ0E7QUFDQTs7QUFDQSxJQUFJQSxTQUFTLEdBQUksVUFBUSxTQUFLQSxTQUFkLElBQTRCLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxDQUEvQixFQUFrQ0MsU0FBbEMsRUFBNkM7QUFDckYsU0FBTyxLQUFLRCxDQUFDLEtBQUtBLENBQUMsR0FBR0UsT0FBVCxDQUFOLEVBQXlCLFVBQVVDLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTJCO0FBQ3ZELGFBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO0FBQUUsVUFBSTtBQUFFQyxRQUFBQSxJQUFJLENBQUNOLFNBQVMsQ0FBQ08sSUFBVixDQUFlRixLQUFmLENBQUQsQ0FBSjtBQUE4QixPQUFwQyxDQUFxQyxPQUFPRyxDQUFQLEVBQVU7QUFBRUwsUUFBQUEsTUFBTSxDQUFDSyxDQUFELENBQU47QUFBWTtBQUFFOztBQUMzRixhQUFTQyxRQUFULENBQWtCSixLQUFsQixFQUF5QjtBQUFFLFVBQUk7QUFBRUMsUUFBQUEsSUFBSSxDQUFDTixTQUFTLENBQUMsT0FBRCxDQUFULENBQW1CSyxLQUFuQixDQUFELENBQUo7QUFBa0MsT0FBeEMsQ0FBeUMsT0FBT0csQ0FBUCxFQUFVO0FBQUVMLFFBQUFBLE1BQU0sQ0FBQ0ssQ0FBRCxDQUFOO0FBQVk7QUFBRTs7QUFDOUYsYUFBU0YsSUFBVCxDQUFjSSxN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QWQ7QUFDSCxhQUpnRixDQUFqRjtBQUtIO0FBQ0osU0FaRCxTQWFRO0FBQ0osZUFBS0YsK0JBQUwsR0FBdUMsQ0FBQyxDQUF4QztBQUNBLGVBQUtFLE1BQUwsR0FBYyxLQUFkO0FBQ0EsZUFBS0Qsb0JBQUwsR0FBNEIsS0FBNUI7QUFDSDtBQUNKLE9BbkJELEVBbUJHLEVBbkJIO0FBb0JILEtBdkJlLENBQWhCO0FBd0JIOztBQTdFOEI7O0FBK0VuQ2pCLE9BQU8sQ0FBQ1MsNEJBQVIsR0FBdUNBLDRCQUF2QyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHRpbWVyc18xID0gcmVxdWlyZShcInRpbWVyc1wiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2FwcGxpY2F0aW9uL3R5cGVzXCIpO1xuY29uc3QgdHlwZXNfMiA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHlwZXNcIik7XG5jb25zdCBhdXRvUGVwOEZvcm1hdHRlcl8xID0gcmVxdWlyZShcIi4vLi4vZm9ybWF0dGVycy9hdXRvUGVwOEZvcm1hdHRlclwiKTtcbmNvbnN0IGJsYWNrRm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi8uLi9mb3JtYXR0ZXJzL2JsYWNrRm9ybWF0dGVyXCIpO1xuY29uc3QgZHVtbXlGb3JtYXR0ZXJfMSA9IHJlcXVpcmUoXCIuLy4uL2Zvcm1hdHRlcnMvZHVtbXlGb3JtYXR0ZXJcIik7XG5jb25zdCB5YXBmRm9ybWF0dGVyXzEgPSByZXF1aXJlKFwiLi8uLi9mb3JtYXR0ZXJzL3lhcGZGb3JtYXR0ZXJcIik7XG5jbGFzcyBQeXRob25Gb3JtYXR0aW5nRWRpdFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBzZXJ2aWNlQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlcyA9IFtdO1xuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvNDExOTRcbiAgICAgICAgdGhpcy5kb2N1bWVudFZlcnNpb25CZWZvcmVGb3JtYXR0aW5nID0gLTE7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVyTWFkZUNoYW5nZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgeWFwZkZvcm1hdHRlciA9IG5ldyB5YXBmRm9ybWF0dGVyXzEuWWFwZkZvcm1hdHRlcihzZXJ2aWNlQ29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgYXV0b1BlcDggPSBuZXcgYXV0b1BlcDhGb3JtYXR0ZXJfMS5BdXRvUGVwOEZvcm1hdHRlcihzZXJ2aWNlQ29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgYmxhY2sgPSBuZXcgYmxhY2tGb3JtYXR0ZXJfMS5CbGFja0Zvcm1hdHRlcihzZXJ2aWNlQ29udGFpbmVyKTtcbiAgICAgICAgY29uc3QgZHVtbXkgPSBuZXcgZHVtbXlGb3JtYXR0ZXJfMS5EdW1teUZvcm1hdHRlcihzZXJ2aWNlQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXJzLnNldCh5YXBmRm9ybWF0dGVyLklkLCB5YXBmRm9ybWF0dGVyKTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXJzLnNldChibGFjay5JZCwgYmxhY2spO1xuICAgICAgICB0aGlzLmZvcm1hdHRlcnMuc2V0KGF1dG9QZXA4LklkLCBhdXRvUGVwOCk7XG4gICAgICAgIHRoaXMuZm9ybWF0dGVycy5zZXQoZHVtbXkuSWQsIGR1bW15KTtcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSUNvbW1hbmRNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy53b3Jrc3BhY2UgPSBzZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18xLklXb3Jrc3BhY2VTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudE1hbmFnZXIgPSBzZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18xLklEb2N1bWVudE1hbmFnZXIpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzIuSUNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlcy5wdXNoKHRoaXMuZG9jdW1lbnRNYW5hZ2VyLm9uRGlkU2F2ZVRleHREb2N1bWVudCgoZG9jdW1lbnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIHRoaXMub25TYXZlRG9jdW1lbnQoZG9jdW1lbnQpOyB9KSkpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGVzLmZvckVhY2goZCA9PiBkLmRpc3Bvc2UoKSk7XG4gICAgfVxuICAgIHByb3ZpZGVEb2N1bWVudEZvcm1hdHRpbmdFZGl0cyhkb2N1bWVudCwgb3B0aW9ucywgdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRWRpdHMoZG9jdW1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucywgdG9rZW4pO1xuICAgIH1cbiAgICBwcm92aWRlRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0cyhkb2N1bWVudCwgcmFuZ2UsIG9wdGlvbnMsIHRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvNDExOTRcbiAgICAgICAgICAgIC8vIFZTQyByZWplY3RzICdmb3JtYXQgb24gc2F2ZScgcHJvbWlzZSBpbiA3NTAgbXMuIFB5dGhvbiBmb3JtYXR0aW5nIG1heSB0YWtlIHF1aXRlIGEgYml0IGxvbmdlci5cbiAgICAgICAgICAgIC8vIFdvcmthcm91bmQgaXMgdG8gcmVzb2x2ZSBwcm9taXNlIHRvIG5vdGhpbmcgaGVyZSwgdGhlbiBleGVjdXRlIGZvcm1hdCBkb2N1bWVudCBhbmQgZm9yY2UgbmV3IHNhdmUuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB3ZSBuZWVkIHRvIGtub3cgaWYgdGhpcyBpcyAnZm9ybWF0IGRvY3VtZW50JyBvciBmb3JtYXR0aW5nIG9uIHNhdmUuXG4gICAgICAgICAgICBpZiAodGhpcy5zYXZpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBhcmUgc2F2aW5nIGFmdGVyIGZvcm1hdHRpbmcgKHNlZSBvblNhdmVEb2N1bWVudCBiZWxvdylcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkbyBub3Qgd2FudCB0byBmb3JtYXQgYWdhaW4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVtZW1iZXIgY29udGVudCBiZWZvcmUgZm9ybWF0dGluZyBzbyB3ZSBjYW4gZGV0ZWN0IGlmXG4gICAgICAgICAgICAvLyBmb3JtYXR0aW5nIGVkaXRzIGhhdmUgYmVlbiByZWFsbHkgYXBwbGllZFxuICAgICAgICAgICAgY29uc3QgZWRpdG9yQ29uZmlnID0gdGhpcy53b3Jrc3BhY2UuZ2V0Q29uZmlndXJhdGlvbignZWRpdG9yJywgZG9jdW1lbnQudXJpKTtcbiAgICAgICAgICAgIGlmIChlZGl0b3JDb25maWcuZ2V0KCdmb3JtYXRPblNhdmUnKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRWZXJzaW9uQmVmb3JlRm9ybWF0dGluZyA9IGRvY3VtZW50LnZlcnNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMuY29uZmlnLmdldFNldHRpbmdzKGRvY3VtZW50LnVyaSk7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSB0aGlzLmZvcm1hdHRlcnMuZ2V0KHNldHRpbmdzLmZvcm1hdHRpbmcucHJvdmlkZXIpO1xuICAgICAgICAgICAgY29uc3QgZWRpdHMgPSB5aWVsZCBmb3JtYXR0ZXIuZm9ybWF0RG9jdW1lbnQoZG9jdW1lbnQsIG9wdGlvbnMsIHRva2VuLCByYW5nZSk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlck1hZGVDaGFuZ2VzID0gZWRpdHMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIHJldHVybiBlZGl0cztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uU2F2ZURvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBQcm9taXNlIHdhcyByZWplY3RlZCA9IGZvcm1hdHRpbmcgdG9vayB0b28gbG9uZy5cbiAgICAgICAgICAgIC8vIERvbid0IGZvcm1hdCBpbnNpZGUgdGhlIGV2ZW50IGhhbmRsZXIsIGRvIGl0IG9uIHRpbWVvdXRcbiAgICAgICAgICAgIHRpbWVyc18xLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcm1hdHRlck1hZGVDaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiAhZG9jdW1lbnQuaXNEaXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZG9jdW1lbnQudmVyc2lvbiA9PT0gdGhpcy5kb2N1bWVudFZlcnNpb25CZWZvcmVGb3JtYXR0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXR0ZXIgY2hhbmdlcyB3ZXJlIG5vdCBhY3R1YWxseSBhcHBsaWVkIGR1ZSB0byB0aGUgdGltZW91dCBvbiBzYXZlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgZm9ybWF0dGluZyBub3cgYW5kIHRoZW4gc2F2ZSB0aGUgZG9jdW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWN1dGVDb21tYW5kKCdlZGl0b3IuYWN0aW9uLmZvcm1hdERvY3VtZW50JykudGhlbigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGRvY3VtZW50LnNhdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNhdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvY3VtZW50VmVyc2lvbkJlZm9yZUZvcm1hdHRpbmcgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZXJNYWRlQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5QeXRob25Gb3JtYXR0aW5nRWRpdFByb3ZpZGVyID0gUHl0aG9uRm9ybWF0dGluZ0VkaXRQcm92aWRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdFByb3ZpZGVyLmpzLm1hcCJdfQ==