"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

class DebugClientHelper {
  constructor(envParser, pathUtils, process) {
    this.envParser = envParser;
    this.pathUtils = pathUtils;
    this.process = process;
  }

  getEnvironmentVariables(args) {
    return __awaiter(this, void 0, void 0, function* () {
      const pathVariableName = this.pathUtils.getPathVariableName(); // Merge variables from both .env file and env json variables.

      const envFileVars = yield this.envParser.parseFile(args.envFile); // tslint:disable-next-line:no-any

      const debugLaunchEnvVars = args.env && Object.keys(args.env).length > 0 ? Object.assign({}, args.env) : {};
      const env = envFileVars ? Object.assign({}, envFileVars) : {};
      this.envParser.mergeVariables(debugLaunchEnvVars, env); // Append the PYTHONPATH and PATH variables.

      this.envParser.appendPath(env, debugLaunchEnvVars[pathVariableName]);
      this.envParser.appendPythonPath(env, debugLaunchEnvVars.PYTHONPATH);

      if (typeof env[pathVariableName] === 'string' && env[pathVariableName].length > 0) {
        // Now merge this path with the current system path.
        // We need to do this to ensure the PATH variable always has the system PATHs as well.
        this.envParser.appendPath(env, this.process.env[pathVariableName]);
      }

      if (typeof env.PYTHONPATH === 'string' && env.PYTHONPATH.length > 0) {
        // We didn't have a value for PATH earlier and now we do.
        // Now merge this path with the current system path.
        // We need to do this to ensure the PATH variable always has the system PATHs as well.
        this.envParser.appendPythonPath(env, this.process.env.PYTHONPATH);
      }

      if (typeof args.console !== 'string' || args.console === 'none') {
        // For debugging, when not using any terminal, then we need to provide all env variables.
        // As we're spawning the process, we need to ensure all env variables are passed.
        // Including those from the current process (i.e. everything, not just custom vars).
        this.envParser.mergeVariables(this.process.env, env);

        if (env[pathVariableName] === undefined && typeof this.process.env[pathVariableName] === 'string') {
          env[pathVariableName] = this.process.env[pathVariableName];
        }

        if (env.PYTHONPATH === undefined && typeof this.process.env.PYTHONPATH === 'string') {
          env.PYTHONPATH = this.process.env.PYTHONPATH;
        }
      }

      if (!env.hasOwnProperty('PYTHONIOENCODING')) {
        env.PYTHONIOENCODING = 'UTF-8';
      }

      if (!env.hasOwnProperty('PYTHONUNBUFFERED')) {
        env.PYTHONUNBUFFERED = '1';
      }

      if (args.gevent) {
        env.GEVENT_SUPPORT = 'True'; // this is read in pydevd_constants.py
      }

      return env;
    });
  }

}

exports.DebugClientHelper = DebugClientHelper;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImhlbHBlci5qcyJdLCJuYW1lcyI6WyJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInZhbHVlIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwiRGVidWdDbGllbnRIZWxwZXIiLCJjb25zdHJ1Y3RvciIsImVudlBhcnNlciIsInBhdGhVdGlscyIsInByb2Nlc3MiLCJnZXRFbnZpcm9ubWVudFZhcmlhYmxlcyIsImFyZ3MiLCJwYXRoVmFyaWFibGVOYW1lIiwiZ2V0UGF0aFZhcmlhYmxlTmFtZSIsImVudkZpbGVWYXJzIiwicGFyc2VGaWxlIiwiZW52RmlsZSIsImRlYnVnTGF1bmNoRW52VmFycyIsImVudiIsImtleXMiLCJsZW5ndGgiLCJhc3NpZ24iLCJtZXJnZVZhcmlhYmxlcyIsImFwcGVuZFBhdGgiLCJhcHBlbmRQeXRob25QYXRoIiwiUFlUSE9OUEFUSCIsImNvbnNvbGUiLCJ1bmRlZmluZWQiLCJoYXNPd25Qcm9wZXJ0eSIsIlBZVEhPTklPRU5DT0RJTkciLCJQWVRIT05VTkJVRkZFUkVEIiwiZ2V2ZW50IiwiR0VWRU5UX1NVUFBPUlQiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBLElBQUlBLFNBQVMsR0FBSSxVQUFRLFNBQUtBLFNBQWQsSUFBNEIsVUFBVUMsT0FBVixFQUFtQkMsVUFBbkIsRUFBK0JDLENBQS9CLEVBQWtDQyxTQUFsQyxFQUE2QztBQUNyRixTQUFPLEtBQUtELENBQUMsS0FBS0EsQ0FBQyxHQUFHRSxPQUFULENBQU4sRUFBeUIsVUFBVUMsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7QUFDdkQsYUFBU0MsU0FBVCxDQUFtQkMsS0FBbkIsRUFBMEI7QUFBRSxVQUFJO0FBQUVDLFFBQUFBLElB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Sjs7QUFDRCxVQUFJLENBQUNQLEdBQUcsQ0FBQ1UsY0FBSixDQUFtQixrQkFBbkIsQ0FBTCxFQUE2QztBQUN6Q1YsUUFBQUEsR0FBRyxDQUFDVyxnQkFBSixHQUF1QixPQUF2QjtBQUNIOztBQUNELFVBQUksQ0FBQ1gsR0FBRyxDQUFDVSxjQUFKLENBQW1CLGtCQUFuQixDQUFMLEVBQTZDO0FBQ3pDVixRQUFBQSxHQUFHLENBQUNZLGdCQUFKLEdBQXVCLEdBQXZCO0FBQ0g7O0FBQ0QsVUFBSW5CLElBQUksQ0FBQ29CLE1BQVQsRUFBaUI7QUFDYmIsUUFBQUEsR0FBRyxDQUFDYyxjQUFKLEdBQXFCLE1BQXJCLENBRGEsQ0FDZ0I7QUFDaEM7O0FBQ0QsYUFBT2QsR0FBUDtBQUNILEtBNUNlLENBQWhCO0FBNkNIOztBQXBEbUI7O0FBc0R4QmQsT0FBTyxDQUFDQyxpQkFBUixHQUE0QkEsaUJBQTVCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIERlYnVnQ2xpZW50SGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbnZQYXJzZXIsIHBhdGhVdGlscywgcHJvY2Vzcykge1xuICAgICAgICB0aGlzLmVudlBhcnNlciA9IGVudlBhcnNlcjtcbiAgICAgICAgdGhpcy5wYXRoVXRpbHMgPSBwYXRoVXRpbHM7XG4gICAgICAgIHRoaXMucHJvY2VzcyA9IHByb2Nlc3M7XG4gICAgfVxuICAgIGdldEVudmlyb25tZW50VmFyaWFibGVzKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhWYXJpYWJsZU5hbWUgPSB0aGlzLnBhdGhVdGlscy5nZXRQYXRoVmFyaWFibGVOYW1lKCk7XG4gICAgICAgICAgICAvLyBNZXJnZSB2YXJpYWJsZXMgZnJvbSBib3RoIC5lbnYgZmlsZSBhbmQgZW52IGpzb24gdmFyaWFibGVzLlxuICAgICAgICAgICAgY29uc3QgZW52RmlsZVZhcnMgPSB5aWVsZCB0aGlzLmVudlBhcnNlci5wYXJzZUZpbGUoYXJncy5lbnZGaWxlKTtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgICAgIGNvbnN0IGRlYnVnTGF1bmNoRW52VmFycyA9IChhcmdzLmVudiAmJiBPYmplY3Qua2V5cyhhcmdzLmVudikubGVuZ3RoID4gMCkgPyBPYmplY3QuYXNzaWduKHt9LCBhcmdzLmVudikgOiB7fTtcbiAgICAgICAgICAgIGNvbnN0IGVudiA9IGVudkZpbGVWYXJzID8gT2JqZWN0LmFzc2lnbih7fSwgZW52RmlsZVZhcnMpIDoge307XG4gICAgICAgICAgICB0aGlzLmVudlBhcnNlci5tZXJnZVZhcmlhYmxlcyhkZWJ1Z0xhdW5jaEVudlZhcnMsIGVudik7XG4gICAgICAgICAgICAvLyBBcHBlbmQgdGhlIFBZVEhPTlBBVEggYW5kIFBBVEggdmFyaWFibGVzLlxuICAgICAgICAgICAgdGhpcy5lbnZQYXJzZXIuYXBwZW5kUGF0aChlbnYsIGRlYnVnTGF1bmNoRW52VmFyc1twYXRoVmFyaWFibGVOYW1lXSk7XG4gICAgICAgICAgICB0aGlzLmVudlBhcnNlci5hcHBlbmRQeXRob25QYXRoKGVudiwgZGVidWdMYXVuY2hFbnZWYXJzLlBZVEhPTlBBVEgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnZbcGF0aFZhcmlhYmxlTmFtZV0gPT09ICdzdHJpbmcnICYmIGVudltwYXRoVmFyaWFibGVOYW1lXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gTm93IG1lcmdlIHRoaXMgcGF0aCB3aXRoIHRoZSBjdXJyZW50IHN5c3RlbSBwYXRoLlxuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyB0byBlbnN1cmUgdGhlIFBBVEggdmFyaWFibGUgYWx3YXlzIGhhcyB0aGUgc3lzdGVtIFBBVEhzIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgdGhpcy5lbnZQYXJzZXIuYXBwZW5kUGF0aChlbnYsIHRoaXMucHJvY2Vzcy5lbnZbcGF0aFZhcmlhYmxlTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBlbnYuUFlUSE9OUEFUSCA9PT0gJ3N0cmluZycgJiYgZW52LlBZVEhPTlBBVEgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRpZG4ndCBoYXZlIGEgdmFsdWUgZm9yIFBBVEggZWFybGllciBhbmQgbm93IHdlIGRvLlxuICAgICAgICAgICAgICAgIC8vIE5vdyBtZXJnZSB0aGlzIHBhdGggd2l0aCB0aGUgY3VycmVudCBzeXN0ZW0gcGF0aC5cbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgdG8gZW5zdXJlIHRoZSBQQVRIIHZhcmlhYmxlIGFsd2F5cyBoYXMgdGhlIHN5c3RlbSBQQVRIcyBhcyB3ZWxsLlxuICAgICAgICAgICAgICAgIHRoaXMuZW52UGFyc2VyLmFwcGVuZFB5dGhvblBhdGgoZW52LCB0aGlzLnByb2Nlc3MuZW52LlBZVEhPTlBBVEgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzLmNvbnNvbGUgIT09ICdzdHJpbmcnIHx8IGFyZ3MuY29uc29sZSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGRlYnVnZ2luZywgd2hlbiBub3QgdXNpbmcgYW55IHRlcm1pbmFsLCB0aGVuIHdlIG5lZWQgdG8gcHJvdmlkZSBhbGwgZW52IHZhcmlhYmxlcy5cbiAgICAgICAgICAgICAgICAvLyBBcyB3ZSdyZSBzcGF3bmluZyB0aGUgcHJvY2Vzcywgd2UgbmVlZCB0byBlbnN1cmUgYWxsIGVudiB2YXJpYWJsZXMgYXJlIHBhc3NlZC5cbiAgICAgICAgICAgICAgICAvLyBJbmNsdWRpbmcgdGhvc2UgZnJvbSB0aGUgY3VycmVudCBwcm9jZXNzIChpLmUuIGV2ZXJ5dGhpbmcsIG5vdCBqdXN0IGN1c3RvbSB2YXJzKS5cbiAgICAgICAgICAgICAgICB0aGlzLmVudlBhcnNlci5tZXJnZVZhcmlhYmxlcyh0aGlzLnByb2Nlc3MuZW52LCBlbnYpO1xuICAgICAgICAgICAgICAgIGlmIChlbnZbcGF0aFZhcmlhYmxlTmFtZV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdGhpcy5wcm9jZXNzLmVudltwYXRoVmFyaWFibGVOYW1lXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZW52W3BhdGhWYXJpYWJsZU5hbWVdID0gdGhpcy5wcm9jZXNzLmVudltwYXRoVmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVudi5QWVRIT05QQVRIID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHRoaXMucHJvY2Vzcy5lbnYuUFlUSE9OUEFUSCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgZW52LlBZVEhPTlBBVEggPSB0aGlzLnByb2Nlc3MuZW52LlBZVEhPTlBBVEg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFlbnYuaGFzT3duUHJvcGVydHkoJ1BZVEhPTklPRU5DT0RJTkcnKSkge1xuICAgICAgICAgICAgICAgIGVudi5QWVRIT05JT0VOQ09ESU5HID0gJ1VURi04JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZW52Lmhhc093blByb3BlcnR5KCdQWVRIT05VTkJVRkZFUkVEJykpIHtcbiAgICAgICAgICAgICAgICBlbnYuUFlUSE9OVU5CVUZGRVJFRCA9ICcxJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhcmdzLmdldmVudCkge1xuICAgICAgICAgICAgICAgIGVudi5HRVZFTlRfU1VQUE9SVCA9ICdUcnVlJzsgLy8gdGhpcyBpcyByZWFkIGluIHB5ZGV2ZF9jb25zdGFudHMucHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbnY7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVidWdDbGllbnRIZWxwZXIgPSBEZWJ1Z0NsaWVudEhlbHBlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhlbHBlci5qcy5tYXAiXX0=