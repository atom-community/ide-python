"use strict"; // Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const inversify_1 = require("inversify");

const path = require("path");

const constants_1 = require("../constants");

const errorUtils_1 = require("../errors/errorUtils");

const moduleNotInstalledError_1 = require("../errors/moduleNotInstalledError");

const types_1 = require("../platform/types");

const platform_1 = require("../utils/platform");

let PythonExecutionService = class PythonExecutionService {
  constructor(serviceContainer, procService, pythonPath) {
    this.procService = procService;
    this.pythonPath = pythonPath;
    this.fileSystem = serviceContainer.get(types_1.IFileSystem);
  }

  getInterpreterInformation() {
    return __awaiter(this, void 0, void 0, function* () {
      const file = path.join(constants_1.EXTENSION_ROOT_DIR, 'pythonFiles', 'interpreterInfo.py');

      try {
        const [version, jsonValue] = yield Promise.all([this.procService.exec(this.pythonPath, ['--version'], {
          mergeStdOutErr: true
        }).then(output => output.stdout.trim()), this.procService.exec(this.pythonPath, [file], {
          mergeStdOutErr: true
        }).then(output => output.stdout.trim())]);
        const json = JSON.parse(jsonValue);
        const version_info = json.versionInfo; // Exclude PII from `version_info` to ensure we don't send this up via telemetry.

        for (let index = 0; index < 3; index += 1) {
          if (typeof version_info[index] !== 'number') {
            version_info[index] = 0;
          }
        }

        if (['alpha', 'beta', 'candidate', 'final'].indexOf(version_info[3]) === -1) {
          version_info[3] = 'unknown';
        }

        return {
          architecture: json.is64Bit ? platform_1.Architecture.x64 : platform_1.Architecture.x86,
          path: this.pythonPath,
          version,
          sysVersion: json.sysVersion,
          version_info: json.versionInfo,
          sysPrefix: json.sysPrefix
        };
      } catch (ex) {
        console.error(`Failed to get interpreter information for '${this.pythonPath}'`, ex);
      }
    });
  }

  getExecutablePath() {
    return __awaiter(this, void 0, void 0, function* () {
      // If we've passed the python file, then return the file.
      // This is because on mac if using the interpreter /usr/bin/python2.7 we can get a different value for the path
      if (yield this.fileSystem.fileExists(this.pythonPath)) {
        return this.pythonPath;
      }

      return this.procService.exec(this.pythonPath, ['-c', 'import sys;print(sys.executable)'], {
        throwOnStdErr: true
      }).then(output => output.stdout.trim());
    });
  }

  isModuleInstalled(moduleName) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.procService.exec(this.pythonPath, ['-c', `import ${moduleName}`], {
        throwOnStdErr: true
      }).then(() => true).catch(() => false);
    });
  }

  execObservable(args, options) {
    const opts = Object.assign({}, options);
    return this.procService.execObservable(this.pythonPath, args, opts);
  }

  execModuleObservable(moduleName, args, options) {
    const opts = Object.assign({}, options);
    return this.procService.execObservable(this.pythonPath, ['-m', moduleName, ...args], opts);
  }

  exec(args, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const opts = Object.assign({}, options);
      return this.procService.exec(this.pythonPath, args, opts);
    });
  }

  execModule(moduleName, args, options) {
    return __awaiter(this, void 0, void 0, function* () {
      const opts = Object.assign({}, options);
      const result = yield this.procService.exec(this.pythonPath, ['-m', moduleName, ...args], opts); // If a module is not installed we'll have something in stderr.

      if (moduleName && errorUtils_1.ErrorUtils.outputHasModuleNotInstalledError(moduleName, result.stderr)) {
        const isInstalled = yield this.isModuleInstalled(moduleName);

        if (!isInstalled) {
          throw new moduleNotInstalledError_1.ModuleNotInstalledError(moduleName);
        }
      }

      return result;
    });
  }

};
PythonExecutionService = __decorate([inversify_1.injectable()], PythonExecutionService);
exports.PythonExecutionService = PythonExecutionService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInB5dGhvblByb2Nlc3MuanMiXSwibmFtZXMiOlsiX19kZWNvcmF0ZSIsImRlY29yYXRvcnMiLCJ0YXJnZXQiLCJrZXkiLCJkZXNjIiwiYyIsImFyZ3VtZW50cyIsImxlbmd0aCIsInIiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJkIiwiUmVmbGVjdCIsImRlY29yYXRlIiwiaSIsImRlZmluZVByb3BlcnR5IiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsImV4cG9ydHMiLCJpbnZlcnNpZnlfMSIsInJlcXVpcmUiLCJwYXRoIiwiY29uc3RhbnRzXzEiLCJlcnJvclV0aWxzXzEiLCJtb2R1bGVOb3RJbnN0YWxsZWRFcnJvcl8xIiwidHlwZXNfMSIsInBsYXRmb3JtXzEiLCJQeXRob25FeGVjdXRpb25TZXJ2aWNlIiwiY29uc3RydWN0b3IiLCJzZXJ2aWNlQ29udGFpbmVyIiwicHJvY1NlcnZpY2UiLCJweXRob25QYXRoIiwiZmlsZVN5c3RlbSIsImdldCIsIklGaWxlU3lzdGVtIiwiZ2V0SW50ZXJwcmV0ZXJJbmZvcm1hdGlvbiIsImZpbGUiLCJqb2luIiwiRVhURU5TSU9OX1JPT1RfRElSIiwidmVyc2lvbiIsImpzb25WYWx1ZSIsImFsbCIsImV4ZWMiLCJtZXJnZVN0ZE91dEVyciIsIm91dHB1dCIsInN0ZG91dCIsInRyaW0iLCJqc29uIiwiSlNPTiIsInBhcnNlIiwidmVyc2lvbl9pbmZvIiwidmVyc2lvbkluZm8iLCJpbmRleCIsImluZGV4T2YiLCJhcmNoaXRlY3R1cmUiLCJpczY0Qml0IiwiQXJjaGl0ZWN0dXJlIiwieDY0IiwieDg2Iiwic3lzVmVyc2lvbiIsInN5c1ByZWZpeCIsImV4IiwiY29uc29sZSIsImVycm9yIiwiZ2V0RXhlY3V0YWJsZVBhdGgiLCJmaWxlRXhpc3RzIiwidGhyb3dPblN0ZEVyciIsImlzTW9kdWxlSW5zdGFsbGVkIiwibW9kdWxlTmFtZSIsImNhdGNoIiwiZXhlY09ic2VydmFibGUiLCJhcmdzIiwib3B0aW9ucyIsIm9wdHMiLCJhc3NpZ24iLCJleGVjTW9kdWxlT2JzZXJ2YWJsZSIsImV4ZWNNb2R1bGUiLCJFcnJvclV0aWxzIiwib3V0cHV0SGFzTW9kdWxlTm90SW5zdGFsbGVkRXJyb3IiLCJzdGRlcnIiLCJpc0luc3RhbGxlZCIsIk1vZHVsZU5vdEluc3RhbGxlZEVycm9yIiwiaW5qZWN0YWJsZSJdLCJtYXBwaW5ncyI6IkFBQUEsYSxDQUNBO0FBQ0E7O0FBQ0EsSUFBSUEsVUFBVSxHQUFJLFVBQVEsU0FBS0EsVUFBZCxJQUE2QixVQUFVQyxVQUFWLEVBQXNCQyxNQUF0QixFQUE4QkMsR0FBOUIsRUFBbUNDLElBQW5DLEVBQXlDO0FBQ25GLE1BQUlDLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUFsQjtBQUFBLE1BQTBCQyxDQUFDLEdBQUdILENBQUMsR0FBRyxDQUFKLEdBQVFILE1BQVIsR0FBaUJFLElBQUksS0FBSyxJQUFULEdBQWdCQSxJQUFJLEdBQUdLLE1BQU0sQ0FBQ0Msd0JBQVAsQ0FBZ0NSLE1BQWhDLEVBQXdDQyxHQUF4QyxDQUF2QixHQUFzRUMsSUFBckg7QUFBQSxNQUEySE8sQ0FBM0g7QUFDQSxNQUFJLE9BQU9DLE9BQVAsS0FBbUIsUUFBbkIsSUFBK0IsT0FBT0EsT0FBTyxDQUFDQyxRQUFmLEtBQTRCLFVBQS9ELEVBQTJFTCxDQUFDLEdBQUdJLE9BQU8sQ0FBQ0MsUUFBUixDQUFpQlosVUFBakIsRUFBNkJDLE1BQTdCLEVBQXFDQyxHQUFyQyxFQUEwQ0MsSUFBMUMsQ0FBSixDQUEzRSxLQUNLLEtBQUssSUFBSVUsQ0FBQyxHQUFHYixVQUFVLENBQUNNLE1BQVgsR0FBb0IsQ0FBakMsRUFBb0NPLENBQUMsSUFBSSxDQUF6QyxFQUE0Q0Es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QUFDc0QsVUFBYixDQUF3QkMsZ0NBQXhCLENBQXlEVixVQUF6RCxFQUFxRXRELE1BQU0sQ0FBQ2lFLE1BQTVFLENBQWxCLEVBQXVHO0FBQ25HLGNBQU1DLFdBQVcsR0FBRyxNQUFNLEtBQUtiLGlCQUFMLENBQXVCQyxVQUF2QixDQUExQjs7QUFDQSxZQUFJLENBQUNZLFdBQUwsRUFBa0I7QUFDZCxnQkFBTSxJQUFJeEQseUJBQXlCLENBQUN5RCx1QkFBOUIsQ0FBc0RiLFVBQXRELENBQU47QUFDSDtBQUNKOztBQUNELGFBQU90RCxNQUFQO0FBQ0gsS0FYZSxDQUFoQjtBQVlIOztBQXJGcUQsQ0FBMUQ7QUF1RkFhLHNCQUFzQixHQUFHM0MsVUFBVSxDQUFDLENBQ2hDbUMsV0FBVyxDQUFDK0QsVUFBWixFQURnQyxDQUFELEVBRWhDdkQsc0JBRmdDLENBQW5DO0FBR0FULE9BQU8sQ0FBQ1Msc0JBQVIsR0FBaUNBLHNCQUFqQyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGludmVyc2lmeV8xID0gcmVxdWlyZShcImludmVyc2lmeVwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGVycm9yVXRpbHNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvZXJyb3JVdGlsc1wiKTtcbmNvbnN0IG1vZHVsZU5vdEluc3RhbGxlZEVycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL21vZHVsZU5vdEluc3RhbGxlZEVycm9yXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi9wbGF0Zm9ybS90eXBlc1wiKTtcbmNvbnN0IHBsYXRmb3JtXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvcGxhdGZvcm1cIik7XG5sZXQgUHl0aG9uRXhlY3V0aW9uU2VydmljZSA9IGNsYXNzIFB5dGhvbkV4ZWN1dGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VDb250YWluZXIsIHByb2NTZXJ2aWNlLCBweXRob25QYXRoKSB7XG4gICAgICAgIHRoaXMucHJvY1NlcnZpY2UgPSBwcm9jU2VydmljZTtcbiAgICAgICAgdGhpcy5weXRob25QYXRoID0gcHl0aG9uUGF0aDtcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JRmlsZVN5c3RlbSk7XG4gICAgfVxuICAgIGdldEludGVycHJldGVySW5mb3JtYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlID0gcGF0aC5qb2luKGNvbnN0YW50c18xLkVYVEVOU0lPTl9ST09UX0RJUiwgJ3B5dGhvbkZpbGVzJywgJ2ludGVycHJldGVySW5mby5weScpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBbdmVyc2lvbiwganNvblZhbHVlXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jU2VydmljZS5leGVjKHRoaXMucHl0aG9uUGF0aCwgWyctLXZlcnNpb24nXSwgeyBtZXJnZVN0ZE91dEVycjogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4ob3V0cHV0ID0+IG91dHB1dC5zdGRvdXQudHJpbSgpKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jU2VydmljZS5leGVjKHRoaXMucHl0aG9uUGF0aCwgW2ZpbGVdLCB7IG1lcmdlU3RkT3V0RXJyOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihvdXRwdXQgPT4gb3V0cHV0LnN0ZG91dC50cmltKCkpXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoanNvblZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJzaW9uX2luZm8gPSBqc29uLnZlcnNpb25JbmZvO1xuICAgICAgICAgICAgICAgIC8vIEV4Y2x1ZGUgUElJIGZyb20gYHZlcnNpb25faW5mb2AgdG8gZW5zdXJlIHdlIGRvbid0IHNlbmQgdGhpcyB1cCB2aWEgdGVsZW1ldHJ5LlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCAzOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmVyc2lvbl9pbmZvW2luZGV4XSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb25faW5mb1tpbmRleF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChbJ2FscGhhJywgJ2JldGEnLCAnY2FuZGlkYXRlJywgJ2ZpbmFsJ10uaW5kZXhPZih2ZXJzaW9uX2luZm9bM10pID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uX2luZm9bM10gPSAndW5rbm93bic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGFyY2hpdGVjdHVyZToganNvbi5pczY0Qml0ID8gcGxhdGZvcm1fMS5BcmNoaXRlY3R1cmUueDY0IDogcGxhdGZvcm1fMS5BcmNoaXRlY3R1cmUueDg2LFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLnB5dGhvblBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgIHN5c1ZlcnNpb246IGpzb24uc3lzVmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbl9pbmZvOiBqc29uLnZlcnNpb25JbmZvLFxuICAgICAgICAgICAgICAgICAgICBzeXNQcmVmaXg6IGpzb24uc3lzUHJlZml4XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBnZXQgaW50ZXJwcmV0ZXIgaW5mb3JtYXRpb24gZm9yICcke3RoaXMucHl0aG9uUGF0aH0nYCwgZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RXhlY3V0YWJsZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSd2ZSBwYXNzZWQgdGhlIHB5dGhvbiBmaWxlLCB0aGVuIHJldHVybiB0aGUgZmlsZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBvbiBtYWMgaWYgdXNpbmcgdGhlIGludGVycHJldGVyIC91c3IvYmluL3B5dGhvbjIuNyB3ZSBjYW4gZ2V0IGEgZGlmZmVyZW50IHZhbHVlIGZvciB0aGUgcGF0aFxuICAgICAgICAgICAgaWYgKHlpZWxkIHRoaXMuZmlsZVN5c3RlbS5maWxlRXhpc3RzKHRoaXMucHl0aG9uUGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5weXRob25QYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvY1NlcnZpY2UuZXhlYyh0aGlzLnB5dGhvblBhdGgsIFsnLWMnLCAnaW1wb3J0IHN5cztwcmludChzeXMuZXhlY3V0YWJsZSknXSwgeyB0aHJvd09uU3RkRXJyOiB0cnVlIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ob3V0cHV0ID0+IG91dHB1dC5zdGRvdXQudHJpbSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzTW9kdWxlSW5zdGFsbGVkKG1vZHVsZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2NTZXJ2aWNlLmV4ZWModGhpcy5weXRob25QYXRoLCBbJy1jJywgYGltcG9ydCAke21vZHVsZU5hbWV9YF0sIHsgdGhyb3dPblN0ZEVycjogdHJ1ZSB9KVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRydWUpLmNhdGNoKCgpID0+IGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4ZWNPYnNlcnZhYmxlKGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jU2VydmljZS5leGVjT2JzZXJ2YWJsZSh0aGlzLnB5dGhvblBhdGgsIGFyZ3MsIG9wdHMpO1xuICAgIH1cbiAgICBleGVjTW9kdWxlT2JzZXJ2YWJsZShtb2R1bGVOYW1lLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvY1NlcnZpY2UuZXhlY09ic2VydmFibGUodGhpcy5weXRob25QYXRoLCBbJy1tJywgbW9kdWxlTmFtZSwgLi4uYXJnc10sIG9wdHMpO1xuICAgIH1cbiAgICBleGVjKGFyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2NTZXJ2aWNlLmV4ZWModGhpcy5weXRob25QYXRoLCBhcmdzLCBvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4ZWNNb2R1bGUobW9kdWxlTmFtZSwgYXJncywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wcm9jU2VydmljZS5leGVjKHRoaXMucHl0aG9uUGF0aCwgWyctbScsIG1vZHVsZU5hbWUsIC4uLmFyZ3NdLCBvcHRzKTtcbiAgICAgICAgICAgIC8vIElmIGEgbW9kdWxlIGlzIG5vdCBpbnN0YWxsZWQgd2UnbGwgaGF2ZSBzb21ldGhpbmcgaW4gc3RkZXJyLlxuICAgICAgICAgICAgaWYgKG1vZHVsZU5hbWUgJiYgZXJyb3JVdGlsc18xLkVycm9yVXRpbHMub3V0cHV0SGFzTW9kdWxlTm90SW5zdGFsbGVkRXJyb3IobW9kdWxlTmFtZSwgcmVzdWx0LnN0ZGVycikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0luc3RhbGxlZCA9IHlpZWxkIHRoaXMuaXNNb2R1bGVJbnN0YWxsZWQobW9kdWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0luc3RhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgbW9kdWxlTm90SW5zdGFsbGVkRXJyb3JfMS5Nb2R1bGVOb3RJbnN0YWxsZWRFcnJvcihtb2R1bGVOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuUHl0aG9uRXhlY3V0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIGludmVyc2lmeV8xLmluamVjdGFibGUoKVxuXSwgUHl0aG9uRXhlY3V0aW9uU2VydmljZSk7XG5leHBvcnRzLlB5dGhvbkV4ZWN1dGlvblNlcnZpY2UgPSBQeXRob25FeGVjdXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHl0aG9uUHJvY2Vzcy5qcy5tYXAiXX0=