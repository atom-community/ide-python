"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const fs = require("fs-extra");

const path = require("path");

const vscode = require("vscode");

const types_1 = require("../common/application/types");

const constants_1 = require("../common/constants");

require("../common/extensions");

const helpers_1 = require("../common/helpers");

const types_2 = require("../common/process/types");

const types_3 = require("../common/types");

const editor_1 = require("./../common/editor");

const types_4 = require("./types");

class BaseFormatter {
  constructor(Id, product, serviceContainer) {
    this.Id = Id;
    this.product = product;
    this.serviceContainer = serviceContainer;
    this.outputChannel = serviceContainer.get(types_3.IOutputChannel, constants_1.STANDARD_OUTPUT_CHANNEL);
    this.helper = serviceContainer.get(types_4.IFormatterHelper);
    this.workspace = serviceContainer.get(types_1.IWorkspaceService);
  }

  getDocumentPath(document, fallbackPath) {
    if (path.basename(document.uri.fsPath) === document.uri.fsPath) {
      return fallbackPath;
    }

    return path.dirname(document.fileName);
  }

  getWorkspaceUri(document) {
    const workspaceFolder = this.workspace.getWorkspaceFolder(document.uri);

    if (workspaceFolder) {
      return workspaceFolder.uri;
    }

    const folders = this.workspace.workspaceFolders;

    if (Array.isArray(folders) && folders.length > 0) {
      return folders[0].uri;
    }

    return vscode.Uri.file(__dirname);
  }

  provideDocumentFormattingEdits(document, options, token, args, cwd) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof cwd !== 'string' || cwd.length === 0) {
        cwd = this.getWorkspaceUri(document).fsPath;
      } // autopep8 and yapf have the ability to read from the process input stream and return the formatted code out of the output stream.
      // However they don't support returning the diff of the formatted text when reading data from the input stream.
      // Yet getting text formatted that way avoids having to create a temporary file, however the diffing will have
      // to be done here in node (extension), i.e. extension CPU, i.e. less responsive solution.


      const tempFile = yield this.createTempFile(document);

      if (this.checkCancellation(document.fileName, tempFile, token)) {
        return [];
      }

      const executionInfo = this.helper.getExecutionInfo(this.product, args, document.uri);
      executionInfo.args.push(tempFile);
      const pythonToolsExecutionService = this.serviceContainer.get(types_2.IPythonToolExecutionService);
      const promise = pythonToolsExecutionService.exec(executionInfo, {
        cwd,
        throwOnStdErr: false,
        token
      }, document.uri).then(output => output.stdout).then(data => {
        if (this.checkCancellation(document.fileName, tempFile, token)) {
          return [];
        }

        return editor_1.getTextEditsFromPatch(document.getText(), data);
      }).catch(error => {
        if (this.checkCancellation(document.fileName, tempFile, token)) {
          return [];
        } // tslint:disable-next-line:no-empty


        this.handleError(this.Id, error, document.uri).catch(() => {});
        return [];
      }).then(edits => {
        this.deleteTempFile(document.fileName, tempFile).ignoreErrors();
        return edits;
      });
      vscode.window.setStatusBarMessage(`Formatting with ${this.Id}`, promise);
      return promise;
    });
  }

  handleError(expectedFileName, error, resource) {
    return __awaiter(this, void 0, void 0, function* () {
      let customError = `Formatting with ${this.Id} failed.`;

      if (helpers_1.isNotInstalledError(error)) {
        const installer = this.serviceContainer.get(types_3.IInstaller);
        const isInstalled = yield installer.isInstalled(this.product, resource);

        if (!isInstalled) {
          customError += `\nYou could either install the '${this.Id}' formatter, turn it off or use another formatter.`;
          installer.promptToInstall(this.product, resource).catch(ex => console.error('Python Extension: promptToInstall', ex));
        }
      }

      this.outputChannel.appendLine(`\n${customError}\n${error}`);
    });
  }

  createTempFile(document) {
    return __awaiter(this, void 0, void 0, function* () {
      return document.isDirty ? editor_1.getTempFileWithDocumentContents(document) : document.fileName;
    });
  }

  deleteTempFile(originalFile, tempFile) {
    if (originalFile !== tempFile) {
      return fs.unlink(tempFile);
    }

    return Promise.resolve();
  }

  checkCancellation(originalFile, tempFile, token) {
    if (token && token.isCancellationRequested) {
      this.deleteTempFile(originalFile, tempFile).ignoreErrors();
      return true;
    }

    return false;
  }

}

exports.BaseFormatter = BaseFormatter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJhc2VGb3JtYXR0ZXIuanMiXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJ2YWx1ZSIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImZzIiwicmVxdWlyZSIsInBhdGgiLCJ2c2NvZGUiLCJ0eXBlc18xIiwiY29uc3RhbnRzXzEiLCJoZWxwZXJzXzEiLCJ0eXBlc18yIiwidHlwZXNfMyIsImVkaXRvcl8xIiwidHlwZXNfNCIsIkJhc2VGb3JtYXR0ZXIiLCJjb25zdHJ1Y3RvciIsIklkIiwicHJvZHVjdCIsInNlcnZpY2VDb250YWluZXIiLCJvdXRwdXRDaGFubmVsIiwiZ2V0IiwiSU91dHB1dENoYW5uZWwiLCJTVEFOREFSRF9PVVRQVVRfQ0hBTk5FTCIsImhlbHBlciIsIklGb3JtYXR0ZXJIZWxwZXIiLCJ3b3Jrc3BhY2UiLCJJV29ya3NwYWNlU2VydmljZSIsImdldERvY3VtZW50UGF0aCIsImRvY3VtZW50IiwiZmFsbGJhY2tQYXRoIiwiYmFzZW5hbWUiLCJ1cmkiLCJmc1BhdGgiLCJkaXJuYW1lIiwiZmlsZU5hbWUiLCJnZXRXb3Jrc3BhY2VVcmkiLCJ3b3Jrc3BhY2VGb2xkZXIiLCJnZXRXb3Jrc3BhY2VGb2xkZXIiLCJmb2xkZXJzIiwid29ya3NwYWNlRm9sZGVycyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsIlVyaSIsImZpbGUiLCJfX2Rpcm5hbWUiLCJwcm92aWRlRG9jdW1lbnRGb3JtYXR0aW5nRWRpdHMiLCJvcHRpb25zIiwidG9rZW4iLCJhcmdzIiwiY3dkIiwidGVtcEZpbGUiLCJjcmVhdGVUZW1wRmlsZSIsImNoZWNrQ2FuY2VsbGF0aW9uIiwiZXhlY3V0aW9uSW5mbyIsImdldEV4ZWN1dGlvbkluZm8iLCJwdXNoIiwicHl0aG9uVG9vbHNFeGVjdXRpb25TZXJ2aWNlIiwiSVB5dGhvblRvb2xFeGVjdXRpb25TZXJ2aWNlIiwicHJvbWlzZSIsImV4ZWMiLCJ0aHJvd09uU3RkRXJyIiwib3V0cHV0Iiwic3Rkb3V0IiwiZGF0YSIsImdldFRleHRFZGl0c0Zyb21QYXRjaCIsImdldFRleHQiLCJjYXRjaCIsImVycm9yIiwiaGFuZGxlRXJyb3IiLCJlZGl0cyIsImRlbGV0ZVRlbXBGaWxlIiwiaWdub3JlRXJyb3JzIiwid2luZG93Iiwic2V0U3RhdHVzQmFyTWVzc2FnZSIsImV4cGVjdGVkRmlsZU5hbWUiLCJyZXNvdXJjZSIsImN1c3RvbUVycm9yIiwiaXNOb3RJbnN0YWxsZWRFcnJvciIsImluc3RhbGxlciIsIklJbnN0YWxsZXIiLCJpc0luc3RhbGxlZCIsInByb21wdFRvSW5zdGFsbCIsImV4IiwiY29uc29sZSIsImFwcGVuZExpbmUiLCJpc0RpcnR5IiwiZ2V0VGVtcEZpbGVXaXRoRG9jdW1lbnRDb250ZW50cyIsIm9yaWdpbmFsRmlsZSIsInVubGluayIsImlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQSxJQUFJQSxTQUFTLEdBQUksVUFBUSxTQUFLQSxTQUFkLElBQTRCLFVBQVVDLE9BQVYsRUFBbUJDLFVBQW5CLEVBQStCQyxDQUEvQixFQUFrQ0MsU0FBbEMsRUFBNkM7QUFDckYsU0FBTyxLQUFLRCxDQUFDLEtBQUtBLENBQUMsR0FBR0UsT0FBVCxDQUFOLEVBQXlCLFVBQVVDLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTJCO0FBQ3ZELGFBQVNDLFNBQVQsQ0FBbUJDLEtBQW5CLEVBQTBCO0FBQUUsVUFBSTtBQUFFQyxRQUFBQSxJQUFJLENBQUNOLFNBQVMsQ0FBQ08sSUFBVixDQUFlRixLQUFmLENBQUQsQ0FBSjtBQUE4QixPQUFwQyxDQUFxQyxPQUFPRyxDQUFQLEVBQVU7QUFBRUwsUUFBQUEsTUFBTSxDQUFDSyxDQUFELENB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QixLQUFSLENBQWMsbUNBQWQsRUFBbURlLEVBQW5ELENBQTlEO0FBQ0g7QUFDSjs7QUFDRCxXQUFLaEUsYUFBTCxDQUFtQmtFLFVBQW5CLENBQStCLEtBQUlSLFdBQVksS0FBSVQsS0FBTSxFQUF6RDtBQUNILEtBWGUsQ0FBaEI7QUFZSDs7QUFDRGhCLEVBQUFBLGNBQWMsQ0FBQ3hCLFFBQUQsRUFBVztBQUNyQixXQUFPOUMsU0FBUyxDQUFDLElBQUQsRUFBTyxLQUFLLENBQVosRUFBZSxLQUFLLENBQXBCLEVBQXVCLGFBQWE7QUFDaEQsYUFBTzhDLFFBQVEsQ0FBQzBELE9BQVQsR0FDRDFFLFFBQVEsQ0FBQzJFLCtCQUFULENBQXlDM0QsUUFBekMsQ0FEQyxHQUVEQSxRQUFRLENBQUNNLFFBRmY7QUFHSCxLQUplLENBQWhCO0FBS0g7O0FBQ0RxQyxFQUFBQSxjQUFjLENBQUNpQixZQUFELEVBQWVyQyxRQUFmLEVBQXlCO0FBQ25DLFFBQUlxQyxZQUFZLEtBQUtyQyxRQUFyQixFQUErQjtBQUMzQixhQUFPaEQsRUFBRSxDQUFDc0YsTUFBSCxDQUFVdEMsUUFBVixDQUFQO0FBQ0g7O0FBQ0QsV0FBT2hFLE9BQU8sQ0FBQ0MsT0FBUixFQUFQO0FBQ0g7O0FBQ0RpRSxFQUFBQSxpQkFBaUIsQ0FBQ21DLFlBQUQsRUFBZXJDLFFBQWYsRUFBeUJILEtBQXpCLEVBQWdDO0FBQzdDLFFBQUlBLEtBQUssSUFBSUEsS0FBSyxDQUFDMEMsdUJBQW5CLEVBQTRDO0FBQ3hDLFdBQUtuQixjQUFMLENBQW9CaUIsWUFBcEIsRUFBa0NyQyxRQUFsQyxFQUE0Q3FCLFlBQTVDO0FBQ0EsYUFBTyxJQUFQO0FBQ0g7O0FBQ0QsV0FBTyxLQUFQO0FBQ0g7O0FBbkdlOztBQXFHcEJ0RSxPQUFPLENBQUNZLGFBQVIsR0FBd0JBLGFBQXhCIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzLWV4dHJhXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgdnNjb2RlID0gcmVxdWlyZShcInZzY29kZVwiKTtcbmNvbnN0IHR5cGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2FwcGxpY2F0aW9uL3R5cGVzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbnN0YW50c1wiKTtcbnJlcXVpcmUoXCIuLi9jb21tb24vZXh0ZW5zaW9uc1wiKTtcbmNvbnN0IGhlbHBlcnNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaGVscGVyc1wiKTtcbmNvbnN0IHR5cGVzXzIgPSByZXF1aXJlKFwiLi4vY29tbW9uL3Byb2Nlc3MvdHlwZXNcIik7XG5jb25zdCB0eXBlc18zID0gcmVxdWlyZShcIi4uL2NvbW1vbi90eXBlc1wiKTtcbmNvbnN0IGVkaXRvcl8xID0gcmVxdWlyZShcIi4vLi4vY29tbW9uL2VkaXRvclwiKTtcbmNvbnN0IHR5cGVzXzQgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmNsYXNzIEJhc2VGb3JtYXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKElkLCBwcm9kdWN0LCBzZXJ2aWNlQ29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuSWQgPSBJZDtcbiAgICAgICAgdGhpcy5wcm9kdWN0ID0gcHJvZHVjdDtcbiAgICAgICAgdGhpcy5zZXJ2aWNlQ29udGFpbmVyID0gc2VydmljZUNvbnRhaW5lcjtcbiAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVsID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMy5JT3V0cHV0Q2hhbm5lbCwgY29uc3RhbnRzXzEuU1RBTkRBUkRfT1VUUFVUX0NIQU5ORUwpO1xuICAgICAgICB0aGlzLmhlbHBlciA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzQuSUZvcm1hdHRlckhlbHBlcik7XG4gICAgICAgIHRoaXMud29ya3NwYWNlID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JV29ya3NwYWNlU2VydmljZSk7XG4gICAgfVxuICAgIGdldERvY3VtZW50UGF0aChkb2N1bWVudCwgZmFsbGJhY2tQYXRoKSB7XG4gICAgICAgIGlmIChwYXRoLmJhc2VuYW1lKGRvY3VtZW50LnVyaS5mc1BhdGgpID09PSBkb2N1bWVudC51cmkuZnNQYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsbGJhY2tQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLmRpcm5hbWUoZG9jdW1lbnQuZmlsZU5hbWUpO1xuICAgIH1cbiAgICBnZXRXb3Jrc3BhY2VVcmkoZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3Qgd29ya3NwYWNlRm9sZGVyID0gdGhpcy53b3Jrc3BhY2UuZ2V0V29ya3NwYWNlRm9sZGVyKGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGlmICh3b3Jrc3BhY2VGb2xkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3b3Jrc3BhY2VGb2xkZXIudXJpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvbGRlcnMgPSB0aGlzLndvcmtzcGFjZS53b3Jrc3BhY2VGb2xkZXJzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmb2xkZXJzKSAmJiBmb2xkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmb2xkZXJzWzBdLnVyaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdnNjb2RlLlVyaS5maWxlKF9fZGlybmFtZSk7XG4gICAgfVxuICAgIHByb3ZpZGVEb2N1bWVudEZvcm1hdHRpbmdFZGl0cyhkb2N1bWVudCwgb3B0aW9ucywgdG9rZW4sIGFyZ3MsIGN3ZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjd2QgIT09ICdzdHJpbmcnIHx8IGN3ZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjd2QgPSB0aGlzLmdldFdvcmtzcGFjZVVyaShkb2N1bWVudCkuZnNQYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXV0b3BlcDggYW5kIHlhcGYgaGF2ZSB0aGUgYWJpbGl0eSB0byByZWFkIGZyb20gdGhlIHByb2Nlc3MgaW5wdXQgc3RyZWFtIGFuZCByZXR1cm4gdGhlIGZvcm1hdHRlZCBjb2RlIG91dCBvZiB0aGUgb3V0cHV0IHN0cmVhbS5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgdGhleSBkb24ndCBzdXBwb3J0IHJldHVybmluZyB0aGUgZGlmZiBvZiB0aGUgZm9ybWF0dGVkIHRleHQgd2hlbiByZWFkaW5nIGRhdGEgZnJvbSB0aGUgaW5wdXQgc3RyZWFtLlxuICAgICAgICAgICAgLy8gWWV0IGdldHRpbmcgdGV4dCBmb3JtYXR0ZWQgdGhhdCB3YXkgYXZvaWRzIGhhdmluZyB0byBjcmVhdGUgYSB0ZW1wb3JhcnkgZmlsZSwgaG93ZXZlciB0aGUgZGlmZmluZyB3aWxsIGhhdmVcbiAgICAgICAgICAgIC8vIHRvIGJlIGRvbmUgaGVyZSBpbiBub2RlIChleHRlbnNpb24pLCBpLmUuIGV4dGVuc2lvbiBDUFUsIGkuZS4gbGVzcyByZXNwb25zaXZlIHNvbHV0aW9uLlxuICAgICAgICAgICAgY29uc3QgdGVtcEZpbGUgPSB5aWVsZCB0aGlzLmNyZWF0ZVRlbXBGaWxlKGRvY3VtZW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGF0aW9uKGRvY3VtZW50LmZpbGVOYW1lLCB0ZW1wRmlsZSwgdG9rZW4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uSW5mbyA9IHRoaXMuaGVscGVyLmdldEV4ZWN1dGlvbkluZm8odGhpcy5wcm9kdWN0LCBhcmdzLCBkb2N1bWVudC51cmkpO1xuICAgICAgICAgICAgZXhlY3V0aW9uSW5mby5hcmdzLnB1c2godGVtcEZpbGUpO1xuICAgICAgICAgICAgY29uc3QgcHl0aG9uVG9vbHNFeGVjdXRpb25TZXJ2aWNlID0gdGhpcy5zZXJ2aWNlQ29udGFpbmVyLmdldCh0eXBlc18yLklQeXRob25Ub29sRXhlY3V0aW9uU2VydmljZSk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gcHl0aG9uVG9vbHNFeGVjdXRpb25TZXJ2aWNlLmV4ZWMoZXhlY3V0aW9uSW5mbywgeyBjd2QsIHRocm93T25TdGRFcnI6IGZhbHNlLCB0b2tlbiB9LCBkb2N1bWVudC51cmkpXG4gICAgICAgICAgICAgICAgLnRoZW4ob3V0cHV0ID0+IG91dHB1dC5zdGRvdXQpXG4gICAgICAgICAgICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsYXRpb24oZG9jdW1lbnQuZmlsZU5hbWUsIHRlbXBGaWxlLCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yXzEuZ2V0VGV4dEVkaXRzRnJvbVBhdGNoKGRvY3VtZW50LmdldFRleHQoKSwgZGF0YSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsYXRpb24oZG9jdW1lbnQuZmlsZU5hbWUsIHRlbXBGaWxlLCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tZW1wdHlcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHRoaXMuSWQsIGVycm9yLCBkb2N1bWVudC51cmkpLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbihlZGl0cyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVUZW1wRmlsZShkb2N1bWVudC5maWxlTmFtZSwgdGVtcEZpbGUpLmlnbm9yZUVycm9ycygpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0cztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdnNjb2RlLndpbmRvdy5zZXRTdGF0dXNCYXJNZXNzYWdlKGBGb3JtYXR0aW5nIHdpdGggJHt0aGlzLklkfWAsIHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihleHBlY3RlZEZpbGVOYW1lLCBlcnJvciwgcmVzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBjdXN0b21FcnJvciA9IGBGb3JtYXR0aW5nIHdpdGggJHt0aGlzLklkfSBmYWlsZWQuYDtcbiAgICAgICAgICAgIGlmIChoZWxwZXJzXzEuaXNOb3RJbnN0YWxsZWRFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnN0YWxsZXIgPSB0aGlzLnNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzMuSUluc3RhbGxlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNJbnN0YWxsZWQgPSB5aWVsZCBpbnN0YWxsZXIuaXNJbnN0YWxsZWQodGhpcy5wcm9kdWN0LCByZXNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0luc3RhbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21FcnJvciArPSBgXFxuWW91IGNvdWxkIGVpdGhlciBpbnN0YWxsIHRoZSAnJHt0aGlzLklkfScgZm9ybWF0dGVyLCB0dXJuIGl0IG9mZiBvciB1c2UgYW5vdGhlciBmb3JtYXR0ZXIuYDtcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFsbGVyLnByb21wdFRvSW5zdGFsbCh0aGlzLnByb2R1Y3QsIHJlc291cmNlKS5jYXRjaChleCA9PiBjb25zb2xlLmVycm9yKCdQeXRob24gRXh0ZW5zaW9uOiBwcm9tcHRUb0luc3RhbGwnLCBleCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3V0cHV0Q2hhbm5lbC5hcHBlbmRMaW5lKGBcXG4ke2N1c3RvbUVycm9yfVxcbiR7ZXJyb3J9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVUZW1wRmlsZShkb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LmlzRGlydHlcbiAgICAgICAgICAgICAgICA/IGVkaXRvcl8xLmdldFRlbXBGaWxlV2l0aERvY3VtZW50Q29udGVudHMoZG9jdW1lbnQpXG4gICAgICAgICAgICAgICAgOiBkb2N1bWVudC5maWxlTmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGV0ZVRlbXBGaWxlKG9yaWdpbmFsRmlsZSwgdGVtcEZpbGUpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsRmlsZSAhPT0gdGVtcEZpbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmcy51bmxpbmsodGVtcEZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgY2hlY2tDYW5jZWxsYXRpb24ob3JpZ2luYWxGaWxlLCB0ZW1wRmlsZSwgdG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVRlbXBGaWxlKG9yaWdpbmFsRmlsZSwgdGVtcEZpbGUpLmlnbm9yZUVycm9ycygpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUZvcm1hdHRlciA9IEJhc2VGb3JtYXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iYXNlRm9ybWF0dGVyLmpzLm1hcCJdfQ==