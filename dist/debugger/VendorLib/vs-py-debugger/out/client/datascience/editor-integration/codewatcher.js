// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
'use strict';

var __decorate = void 0 && (void 0).__decorate || function (decorators, target, key, desc) {
  var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : new P(function (resolve) {
        resolve(result.value);
      }).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const vscode_1 = require("vscode");

const types_1 = require("../../common/application/types");

const contextKey_1 = require("../../common/contextKey");

const types_2 = require("../../common/types");

const localize = require("../../common/utils/localize");

const telemetry_1 = require("../../telemetry");

const constants_1 = require("../constants");

const types_3 = require("../types");

class CodeWatcher {
  constructor(serviceContainer, document) {
    this.version = -1;
    this.fileName = '';
    this.codeLenses = []; // tslint:disable-next-line:no-any

    this.handleError = err => {
      if (err.actionTitle !== undefined) {
        const jupyterError = err; // This is a special error that shows a link to open for more help

        this.applicationShell.showErrorMessage(jupyterError.message, jupyterError.actionTitle).then(v => {
          // User clicked on the link, open it.
          if (v === jupyterError.actionTitle) {
            this.applicationShell.openUrl(jupyterError.action);
          }
        });
      } else if (err.message) {
        this.applicationShell.showErrorMessage(err.message);
      } else {
        this.applicationShell.showErrorMessage(err.toString());
      }

      this.logger.logError(err);
    };

    this.historyProvider = serviceContainer.get(types_3.IHistoryProvider);
    this.commandManager = serviceContainer.get(types_1.ICommandManager);
    this.applicationShell = serviceContainer.get(types_1.IApplicationShell);
    this.logger = serviceContainer.get(types_2.ILogger);
    this.document = document; // Cache these, we don't want to pull an old version if the document is updated

    this.fileName = document.fileName;
    this.version = document.version; // Get document cells here

    const cells = this.getCells(document);
    this.codeLenses = [];
    cells.forEach(cell => {
      const cmd = {
        arguments: [this, cell.range],
        title: localize.DataScience.runCellLensCommandTitle(),
        command: constants_1.Commands.RunCell
      };
      this.codeLenses.push(new vscode_1.CodeLens(cell.range, cmd));
      const runAllCmd = {
        arguments: [this],
        title: localize.DataScience.runAllCellsLensCommandTitle(),
        command: constants_1.Commands.RunAllCells
      };
      this.codeLenses.push(new vscode_1.CodeLens(cell.range, runAllCmd));
    });
  }

  getFileName() {
    return this.fileName;
  }

  getVersion() {
    return this.version;
  }

  getCodeLenses() {
    return this.codeLenses;
  }

  runAllCells() {
    return __awaiter(this, void 0, void 0, function* () {
      const activeHistory = this.historyProvider.active; // Run all of our code lenses, they should always be ordered in the file so we can just
      // run them one by one

      for (const lens of this.codeLenses) {
        // Make sure that we have the correct command (RunCell) lenses
        if (lens.command && lens.command.command === constants_1.Commands.RunCell && lens.command.arguments && lens.command.arguments.length >= 2) {
          const range = lens.command.arguments[1];

          if (this.document && range) {
            const code = this.document.getText(range);
            yield activeHistory.addCode(code, this.getFileName(), range.start.line);
          }
        }
      }
    });
  }

  runCell(range) {
    return __awaiter(this, void 0, void 0, function* () {
      const activeHistory = this.historyProvider.active;

      if (this.document) {
        const code = this.document.getText(range);

        try {
          yield activeHistory.addCode(code, this.getFileName(), range.start.line, vscode_1.window.activeTextEditor);
        } catch (err) {
          this.handleError(err);
        }
      }
    });
  }

  runCurrentCell() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!vscode_1.window.activeTextEditor || !vscode_1.window.activeTextEditor.document) {
        return;
      }

      for (const lens of this.codeLenses) {
        // Check to see which RunCell lens range overlaps the current selection start
        if (lens.range.contains(vscode_1.window.activeTextEditor.selection.start) && lens.command && lens.command.command === constants_1.Commands.RunCell) {
          yield this.runCell(lens.range);
          break;
        }
      }
    });
  }

  runCurrentCellAndAdvance() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!vscode_1.window.activeTextEditor || !vscode_1.window.activeTextEditor.document) {
        return;
      }

      let currentRunCellLens;
      let nextRunCellLens;

      for (const lens of this.codeLenses) {
        // If we have already found the current code lens, then the next run cell code lens will give us the next cell
        if (currentRunCellLens && lens.command && lens.command.command === constants_1.Commands.RunCell) {
          nextRunCellLens = lens;
          break;
        } // Check to see which RunCell lens range overlaps the current selection start


        if (lens.range.contains(vscode_1.window.activeTextEditor.selection.start) && lens.command && lens.command.command === constants_1.Commands.RunCell) {
          currentRunCellLens = lens;
        }
      }

      if (currentRunCellLens) {
        // Either use the next cell that we found, or add a new one into the document
        let nextRange;

        if (!nextRunCellLens) {
          nextRange = this.createNewCell(currentRunCellLens.range);
        } else {
          nextRange = nextRunCellLens.range;
        }

        if (nextRange) {
          this.advanceToRange(nextRange);
        } // Run the cell after moving the selection


        yield this.runCell(currentRunCellLens.range);
      }
    });
  } // User has picked run and advance on the last cell of a document
  // Create a new cell at the bottom and put their selection there, ready to type


  createNewCell(currentRange) {
    const editor = vscode_1.window.activeTextEditor;
    const newPosition = new vscode_1.Position(currentRange.end.line + 3, 0); // +3 to account for the added spaces and to position after the new mark

    if (editor) {
      editor.edit(editBuilder => {
        editBuilder.insert(new vscode_1.Position(currentRange.end.line + 1, 0), '\n\n#%%\n');
      });
    }

    return new vscode_1.Range(newPosition, newPosition);
  } // Advance the cursor to the selected range


  advanceToRange(targetRange) {
    const editor = vscode_1.window.activeTextEditor;
    const newSelection = new vscode_1.Selection(targetRange.start, targetRange.start);

    if (editor) {
      editor.selection = newSelection;
      editor.revealRange(targetRange, vscode_1.TextEditorRevealType.Default);
    }
  } // Implmentation of getCells here based on Don's Jupyter extension work


  getCells(document) {
    const cellIdentifier = constants_1.RegExpValues.PythonCellMarker;
    const editorContext = new contextKey_1.ContextKey(constants_1.EditorContexts.HasCodeCells, this.commandManager);
    const cells = [];

    for (let index = 0; index < document.lineCount; index += 1) {
      const line = document.lineAt(index); // clear regex cache

      cellIdentifier.lastIndex = -1;

      if (cellIdentifier.test(line.text)) {
        const results = cellIdentifier.exec(line.text);

        if (cells.length > 0) {
          const previousCell = cells[cells.length - 1];
          previousCell.range = new vscode_1.Range(previousCell.range.start, document.lineAt(index - 1).range.end);
        }

        if (results !== null) {
          cells.push({
            range: line.range,
            title: results.length > 1 ? results[2].trim() : ''
          });
        }
      }
    }

    if (cells.length >= 1) {
      const line = document.lineAt(document.lineCount - 1);
      const previousCell = cells[cells.length - 1];
      previousCell.range = new vscode_1.Range(previousCell.range.start, line.range.end);
    } // Inform the editor context that we have cells, fire and forget is ok on the promise here
    // as we don't care to wait for this context to be set and we can't do anything if it fails


    editorContext.set(cells.length > 0).catch();
    return cells;
  }

}

__decorate([telemetry_1.captureTelemetry(constants_1.Telemetry.RunAllCells)], CodeWatcher.prototype, "runAllCells", null);

__decorate([telemetry_1.captureTelemetry(constants_1.Telemetry.RunCell)], CodeWatcher.prototype, "runCell", null);

__decorate([telemetry_1.captureTelemetry(constants_1.Telemetry.RunCurrentCell)], CodeWatcher.prototype, "runCurrentCell", null);

__decorate([telemetry_1.captureTelemetry(constants_1.Telemetry.RunCurrentCellAndAdvance)], CodeWatcher.prototype, "runCurrentCellAndAdvance", null);

exports.CodeWatcher = CodeWatcher;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNvZGV3YXRjaGVyLmpzIl0sIm5hbWVzIjpbIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJyIiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZCIsIlJlZmxlY3QiLCJkZWNvcmF0ZSIsImkiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwidmFsdWUiLCJzdGVwIiwibmV4dCIsImUiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJleHBvcnRzIiwidnNjb2RlXzEiLCJyZXF1aXJlIiwidHlwZXNfMSIsImNvbnRleHRLZXlfMSIsInR5cGVzXzIiLCJsb2NhbGl6ZSIsInRlbGVtZXRyeV8xIiwiY29uc3RhbnRzXzEiLCJ0eXBlc18zIiwiQ29kZVdhdGNoZXIiLCJjb25zdHJ1Y3RvciIsInNlcnZpY2VDb250YWluZXIiLCJkb2N1bWVudCIsInZlcnNpb24iLCJmaWxlTmFtZSIsImNvZGVMZW5zZXMiLCJoYW5kbGVFcnJvciIsImVyciIsImFjdGlvblRpdGxlIiwidW5kZWZpbmVkIiwianVweXRlckVycm9yIiwiYXBwbGljYXRpb25TaGVsbCIsInNob3dFcnJvck1lc3NhZ2UiLCJtZXNzYWdlIiwidiIsIm9wZW5VcmwiLCJhY3Rpb24iLCJ0b1N0cmluZyIsImxvZ2dlciIsImxvZ0Vycm9yIiwiaGlzdG9yeVByb3ZpZGVyIiwiZ2V0IiwiSUhpc3RvcnlQcm92aWRlciIsImNvbW1hbmRNYW5hZ2VyIiwiSUNvbW1hbmRNYW5hZ2VyIiwiSUFwcGxpY2F0aW9uU2hlbGwiLCJJTG9nZ2VyIiwiY2VsbHMiLCJnZXRDZWxscyIsImZvckVhY2giLCJjZWxsIiwiY21kIiwicmFuZ2UiLCJ0aXRsZSIsIkRhdGFTY2llbmNlIiwicnVuQ2VsbExlbnNDb21tYW5kVGl0bGUiLCJjb21tYW5kIiwiQ29tbWFuZHMiLCJSdW5DZWxsIiwicHVzaCIsIkNvZGVMZW5zIiwicnVuQWxsQ21kIiwicnVuQWxsQ2VsbHNMZW5zQ29tbWFuZFRpdGxlIiwiUnVuQWxsQ2VsbHMiLCJnZXRGaWxlTmFtZSIsImdldFZlcnNpb24iLCJnZXRDb2RlTGVuc2VzIiwicnVuQWxsQ2VsbHMiLCJhY3RpdmVIaXN0b3J5IiwiYWN0aXZlIiwibGVucyIsImNvZGUiLCJnZXRUZXh0IiwiYWRkQ29kZSIsInN0YXJ0IiwibGluZSIsInJ1bkNlbGwiLCJ3aW5kb3ciLCJhY3RpdmVUZXh0RWRpdG9yIiwicnVuQ3VycmVudENlbGwiLCJjb250YWlucyIsInNlbGVjdGlvbiIsInJ1bkN1cnJlbnRDZWxsQW5kQWR2YW5jZSIsImN1cnJlbnRSdW5DZWxsTGVucyIsIm5leHRSdW5DZWxsTGVucyIsIm5leHRSYW5nZSIsImNyZWF0ZU5ld0NlbGwiLCJhZHZhbmNlVG9SYW5nZSIsImN1cnJlbnRSYW5nZSIsImVkaXRvciIsIm5ld1Bvc2l0aW9uIiwiUG9zaXRpb24iLCJlbmQiLCJlZGl0IiwiZWRpdEJ1aWxkZXIiLCJpbnNlcnQiLCJSYW5nZSIsInRhcmdldFJhbmdlIiwibmV3U2VsZWN0aW9uIiwiU2VsZWN0aW9uIiwicmV2ZWFsUmFuZ2UiLCJUZXh0RWRpdG9yUmV2ZWFsVHlwZSIsIkRlZmF1bHQiLCJjZWxsSWRlbnRpZmllciIsIlJlZ0V4cFZhbHVlcyIsIlB5dGhvbkNlbGxNYXJrZXIiLCJlZGl0b3JDb250ZXh0IiwiQ29udGV4dEtleSIsIkVkaXRvckNvbnRleHRzIiwiSGFzQ29kZUNlbGxzIiwiaW5kZXgiLCJsaW5lQ291bnQiLCJsaW5lQXQiLCJsYXN0SW5kZXgiLCJ0ZXN0IiwidGV4dCIsInJlc3VsdHMiLCJleGVjIiwicHJldmlvdXNDZWxsIiwidHJpbSIsInNldCIsImNhdGNoIiwiY2FwdHVyZVRlbGVtZXRyeSIsIlRlbGVtZXRy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LENBQUMsQ0FDUHlDLFdBQVcsQ0FBQzBHLGdCQUFaLENBQTZCekcsV0FBVyxDQUFDMEcsU0FBWixDQUFzQjVELFdBQW5ELENBRE8sQ0FBRCxFQUVQNUMsV0FBVyxDQUFDeUcsU0FGTCxFQUVnQixhQUZoQixFQUUrQixJQUYvQixDQUFWOztBQUdBckosVUFBVSxDQUFDLENBQ1B5QyxXQUFXLENBQUMwRyxnQkFBWixDQUE2QnpHLFdBQVcsQ0FBQzBHLFNBQVosQ0FBc0JqRSxPQUFuRCxDQURPLENBQUQsRUFFUHZDLFdBQVcsQ0FBQ3lHLFNBRkwsRUFFZ0IsU0FGaEIsRUFFMkIsSUFGM0IsQ0FBVjs7QUFHQXJKLFVBQVUsQ0FBQyxDQUNQeUMsV0FBVyxDQUFDMEcsZ0JBQVosQ0FBNkJ6RyxXQUFXLENBQUMwRyxTQUFaLENBQXNCRSxjQUFuRCxDQURPLENBQUQsRUFFUDFHLFdBQVcsQ0FBQ3lHLFNBRkwsRUFFZ0IsZ0JBRmhCLEVBRWtDLElBRmxDLENBQVY7O0FBR0FySixVQUFVLENBQUMsQ0FDUHlDLFdBQVcsQ0FBQzBHLGdCQUFaLENBQTZCekcsV0FBVyxDQUFDMEcsU0FBWixDQUFzQkcsd0JBQW5ELENBRE8sQ0FBRCxFQUVQM0csV0FBVyxDQUFDeUcsU0FGTCxFQUVnQiwwQkFGaEIsRUFFNEMsSUFGNUMsQ0FBVjs7QUFHQW5ILE9BQU8sQ0FBQ1UsV0FBUixHQUFzQkEsV0FBdEIiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbid1c2Ugc3RyaWN0JztcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdnNjb2RlXzEgPSByZXF1aXJlKFwidnNjb2RlXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vYXBwbGljYXRpb24vdHlwZXNcIik7XG5jb25zdCBjb250ZXh0S2V5XzEgPSByZXF1aXJlKFwiLi4vLi4vY29tbW9uL2NvbnRleHRLZXlcIik7XG5jb25zdCB0eXBlc18yID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi90eXBlc1wiKTtcbmNvbnN0IGxvY2FsaXplID0gcmVxdWlyZShcIi4uLy4uL2NvbW1vbi91dGlscy9sb2NhbGl6ZVwiKTtcbmNvbnN0IHRlbGVtZXRyeV8xID0gcmVxdWlyZShcIi4uLy4uL3RlbGVtZXRyeVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IHR5cGVzXzMgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG5jbGFzcyBDb2RlV2F0Y2hlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZUNvbnRhaW5lciwgZG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gLTE7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSAnJztcbiAgICAgICAgdGhpcy5jb2RlTGVuc2VzID0gW107XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIuYWN0aW9uVGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGp1cHl0ZXJFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBlcnJvciB0aGF0IHNob3dzIGEgbGluayB0byBvcGVuIGZvciBtb3JlIGhlbHBcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGxpY2F0aW9uU2hlbGwuc2hvd0Vycm9yTWVzc2FnZShqdXB5dGVyRXJyb3IubWVzc2FnZSwganVweXRlckVycm9yLmFjdGlvblRpdGxlKS50aGVuKHYgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2VyIGNsaWNrZWQgb24gdGhlIGxpbmssIG9wZW4gaXQuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2ID09PSBqdXB5dGVyRXJyb3IuYWN0aW9uVGl0bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25TaGVsbC5vcGVuVXJsKGp1cHl0ZXJFcnJvci5hY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnIubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25TaGVsbC5zaG93RXJyb3JNZXNzYWdlKGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25TaGVsbC5zaG93RXJyb3JNZXNzYWdlKGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLmxvZ0Vycm9yKGVycik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGlzdG9yeVByb3ZpZGVyID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMy5JSGlzdG9yeVByb3ZpZGVyKTtcbiAgICAgICAgdGhpcy5jb21tYW5kTWFuYWdlciA9IHNlcnZpY2VDb250YWluZXIuZ2V0KHR5cGVzXzEuSUNvbW1hbmRNYW5hZ2VyKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvblNoZWxsID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMS5JQXBwbGljYXRpb25TaGVsbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gc2VydmljZUNvbnRhaW5lci5nZXQodHlwZXNfMi5JTG9nZ2VyKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAvLyBDYWNoZSB0aGVzZSwgd2UgZG9uJ3Qgd2FudCB0byBwdWxsIGFuIG9sZCB2ZXJzaW9uIGlmIHRoZSBkb2N1bWVudCBpcyB1cGRhdGVkXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBkb2N1bWVudC5maWxlTmFtZTtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gZG9jdW1lbnQudmVyc2lvbjtcbiAgICAgICAgLy8gR2V0IGRvY3VtZW50IGNlbGxzIGhlcmVcbiAgICAgICAgY29uc3QgY2VsbHMgPSB0aGlzLmdldENlbGxzKGRvY3VtZW50KTtcbiAgICAgICAgdGhpcy5jb2RlTGVuc2VzID0gW107XG4gICAgICAgIGNlbGxzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjbWQgPSB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBbdGhpcywgY2VsbC5yYW5nZV0sXG4gICAgICAgICAgICAgICAgdGl0bGU6IGxvY2FsaXplLkRhdGFTY2llbmNlLnJ1bkNlbGxMZW5zQ29tbWFuZFRpdGxlKCksXG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29uc3RhbnRzXzEuQ29tbWFuZHMuUnVuQ2VsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuY29kZUxlbnNlcy5wdXNoKG5ldyB2c2NvZGVfMS5Db2RlTGVucyhjZWxsLnJhbmdlLCBjbWQpKTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bkFsbENtZCA9IHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFt0aGlzXSxcbiAgICAgICAgICAgICAgICB0aXRsZTogbG9jYWxpemUuRGF0YVNjaWVuY2UucnVuQWxsQ2VsbHNMZW5zQ29tbWFuZFRpdGxlKCksXG4gICAgICAgICAgICAgICAgY29tbWFuZDogY29uc3RhbnRzXzEuQ29tbWFuZHMuUnVuQWxsQ2VsbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNvZGVMZW5zZXMucHVzaChuZXcgdnNjb2RlXzEuQ29kZUxlbnMoY2VsbC5yYW5nZSwgcnVuQWxsQ21kKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRGaWxlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsZU5hbWU7XG4gICAgfVxuICAgIGdldFZlcnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnNpb247XG4gICAgfVxuICAgIGdldENvZGVMZW5zZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVMZW5zZXM7XG4gICAgfVxuICAgIHJ1bkFsbENlbGxzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlSGlzdG9yeSA9IHRoaXMuaGlzdG9yeVByb3ZpZGVyLmFjdGl2ZTtcbiAgICAgICAgICAgIC8vIFJ1biBhbGwgb2Ygb3VyIGNvZGUgbGVuc2VzLCB0aGV5IHNob3VsZCBhbHdheXMgYmUgb3JkZXJlZCBpbiB0aGUgZmlsZSBzbyB3ZSBjYW4ganVzdFxuICAgICAgICAgICAgLy8gcnVuIHRoZW0gb25lIGJ5IG9uZVxuICAgICAgICAgICAgZm9yIChjb25zdCBsZW5zIG9mIHRoaXMuY29kZUxlbnNlcykge1xuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgdGhlIGNvcnJlY3QgY29tbWFuZCAoUnVuQ2VsbCkgbGVuc2VzXG4gICAgICAgICAgICAgICAgaWYgKGxlbnMuY29tbWFuZCAmJiBsZW5zLmNvbW1hbmQuY29tbWFuZCA9PT0gY29uc3RhbnRzXzEuQ29tbWFuZHMuUnVuQ2VsbCAmJiBsZW5zLmNvbW1hbmQuYXJndW1lbnRzICYmIGxlbnMuY29tbWFuZC5hcmd1bWVudHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBsZW5zLmNvbW1hbmQuYXJndW1lbnRzWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kb2N1bWVudCAmJiByYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuZG9jdW1lbnQuZ2V0VGV4dChyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBhY3RpdmVIaXN0b3J5LmFkZENvZGUoY29kZSwgdGhpcy5nZXRGaWxlTmFtZSgpLCByYW5nZS5zdGFydC5saW5lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bkNlbGwocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUhpc3RvcnkgPSB0aGlzLmhpc3RvcnlQcm92aWRlci5hY3RpdmU7XG4gICAgICAgICAgICBpZiAodGhpcy5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0aGlzLmRvY3VtZW50LmdldFRleHQocmFuZ2UpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGFjdGl2ZUhpc3RvcnkuYWRkQ29kZShjb2RlLCB0aGlzLmdldEZpbGVOYW1lKCksIHJhbmdlLnN0YXJ0LmxpbmUsIHZzY29kZV8xLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuQ3VycmVudENlbGwoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXZzY29kZV8xLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yIHx8ICF2c2NvZGVfMS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvci5kb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVucyBvZiB0aGlzLmNvZGVMZW5zZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgd2hpY2ggUnVuQ2VsbCBsZW5zIHJhbmdlIG92ZXJsYXBzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzdGFydFxuICAgICAgICAgICAgICAgIGlmIChsZW5zLnJhbmdlLmNvbnRhaW5zKHZzY29kZV8xLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yLnNlbGVjdGlvbi5zdGFydCkgJiYgbGVucy5jb21tYW5kICYmIGxlbnMuY29tbWFuZC5jb21tYW5kID09PSBjb25zdGFudHNfMS5Db21tYW5kcy5SdW5DZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucnVuQ2VsbChsZW5zLnJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuQ3VycmVudENlbGxBbmRBZHZhbmNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF2c2NvZGVfMS53aW5kb3cuYWN0aXZlVGV4dEVkaXRvciB8fCAhdnNjb2RlXzEud2luZG93LmFjdGl2ZVRleHRFZGl0b3IuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudFJ1bkNlbGxMZW5zO1xuICAgICAgICAgICAgbGV0IG5leHRSdW5DZWxsTGVucztcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGVucyBvZiB0aGlzLmNvZGVMZW5zZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFscmVhZHkgZm91bmQgdGhlIGN1cnJlbnQgY29kZSBsZW5zLCB0aGVuIHRoZSBuZXh0IHJ1biBjZWxsIGNvZGUgbGVucyB3aWxsIGdpdmUgdXMgdGhlIG5leHQgY2VsbFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UnVuQ2VsbExlbnMgJiYgbGVucy5jb21tYW5kICYmIGxlbnMuY29tbWFuZC5jb21tYW5kID09PSBjb25zdGFudHNfMS5Db21tYW5kcy5SdW5DZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRSdW5DZWxsTGVucyA9IGxlbnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgd2hpY2ggUnVuQ2VsbCBsZW5zIHJhbmdlIG92ZXJsYXBzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBzdGFydFxuICAgICAgICAgICAgICAgIGlmIChsZW5zLnJhbmdlLmNvbnRhaW5zKHZzY29kZV8xLndpbmRvdy5hY3RpdmVUZXh0RWRpdG9yLnNlbGVjdGlvbi5zdGFydCkgJiYgbGVucy5jb21tYW5kICYmIGxlbnMuY29tbWFuZC5jb21tYW5kID09PSBjb25zdGFudHNfMS5Db21tYW5kcy5SdW5DZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSdW5DZWxsTGVucyA9IGxlbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRSdW5DZWxsTGVucykge1xuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB1c2UgdGhlIG5leHQgY2VsbCB0aGF0IHdlIGZvdW5kLCBvciBhZGQgYSBuZXcgb25lIGludG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgbGV0IG5leHRSYW5nZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5leHRSdW5DZWxsTGVucykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UmFuZ2UgPSB0aGlzLmNyZWF0ZU5ld0NlbGwoY3VycmVudFJ1bkNlbGxMZW5zLnJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRSYW5nZSA9IG5leHRSdW5DZWxsTGVucy5yYW5nZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHRSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkdmFuY2VUb1JhbmdlKG5leHRSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFJ1biB0aGUgY2VsbCBhZnRlciBtb3ZpbmcgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucnVuQ2VsbChjdXJyZW50UnVuQ2VsbExlbnMucmFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gVXNlciBoYXMgcGlja2VkIHJ1biBhbmQgYWR2YW5jZSBvbiB0aGUgbGFzdCBjZWxsIG9mIGEgZG9jdW1lbnRcbiAgICAvLyBDcmVhdGUgYSBuZXcgY2VsbCBhdCB0aGUgYm90dG9tIGFuZCBwdXQgdGhlaXIgc2VsZWN0aW9uIHRoZXJlLCByZWFkeSB0byB0eXBlXG4gICAgY3JlYXRlTmV3Q2VsbChjdXJyZW50UmFuZ2UpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdnNjb2RlXzEud2luZG93LmFjdGl2ZVRleHRFZGl0b3I7XG4gICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gbmV3IHZzY29kZV8xLlBvc2l0aW9uKGN1cnJlbnRSYW5nZS5lbmQubGluZSArIDMsIDApOyAvLyArMyB0byBhY2NvdW50IGZvciB0aGUgYWRkZWQgc3BhY2VzIGFuZCB0byBwb3NpdGlvbiBhZnRlciB0aGUgbmV3IG1hcmtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLmVkaXQoKGVkaXRCdWlsZGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgZWRpdEJ1aWxkZXIuaW5zZXJ0KG5ldyB2c2NvZGVfMS5Qb3NpdGlvbihjdXJyZW50UmFuZ2UuZW5kLmxpbmUgKyAxLCAwKSwgJ1xcblxcbiMlJVxcbicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyB2c2NvZGVfMS5SYW5nZShuZXdQb3NpdGlvbiwgbmV3UG9zaXRpb24pO1xuICAgIH1cbiAgICAvLyBBZHZhbmNlIHRoZSBjdXJzb3IgdG8gdGhlIHNlbGVjdGVkIHJhbmdlXG4gICAgYWR2YW5jZVRvUmFuZ2UodGFyZ2V0UmFuZ2UpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdnNjb2RlXzEud2luZG93LmFjdGl2ZVRleHRFZGl0b3I7XG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IG5ldyB2c2NvZGVfMS5TZWxlY3Rpb24odGFyZ2V0UmFuZ2Uuc3RhcnQsIHRhcmdldFJhbmdlLnN0YXJ0KTtcbiAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG5ld1NlbGVjdGlvbjtcbiAgICAgICAgICAgIGVkaXRvci5yZXZlYWxSYW5nZSh0YXJnZXRSYW5nZSwgdnNjb2RlXzEuVGV4dEVkaXRvclJldmVhbFR5cGUuRGVmYXVsdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSW1wbG1lbnRhdGlvbiBvZiBnZXRDZWxscyBoZXJlIGJhc2VkIG9uIERvbidzIEp1cHl0ZXIgZXh0ZW5zaW9uIHdvcmtcbiAgICBnZXRDZWxscyhkb2N1bWVudCkge1xuICAgICAgICBjb25zdCBjZWxsSWRlbnRpZmllciA9IGNvbnN0YW50c18xLlJlZ0V4cFZhbHVlcy5QeXRob25DZWxsTWFya2VyO1xuICAgICAgICBjb25zdCBlZGl0b3JDb250ZXh0ID0gbmV3IGNvbnRleHRLZXlfMS5Db250ZXh0S2V5KGNvbnN0YW50c18xLkVkaXRvckNvbnRleHRzLkhhc0NvZGVDZWxscywgdGhpcy5jb21tYW5kTWFuYWdlcik7XG4gICAgICAgIGNvbnN0IGNlbGxzID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBkb2N1bWVudC5saW5lQ291bnQ7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkb2N1bWVudC5saW5lQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gY2xlYXIgcmVnZXggY2FjaGVcbiAgICAgICAgICAgIGNlbGxJZGVudGlmaWVyLmxhc3RJbmRleCA9IC0xO1xuICAgICAgICAgICAgaWYgKGNlbGxJZGVudGlmaWVyLnRlc3QobGluZS50ZXh0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjZWxsSWRlbnRpZmllci5leGVjKGxpbmUudGV4dCk7XG4gICAgICAgICAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDZWxsID0gY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzQ2VsbC5yYW5nZSA9IG5ldyB2c2NvZGVfMS5SYW5nZShwcmV2aW91c0NlbGwucmFuZ2Uuc3RhcnQsIGRvY3VtZW50LmxpbmVBdChpbmRleCAtIDEpLnJhbmdlLmVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IGxpbmUucmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogcmVzdWx0cy5sZW5ndGggPiAxID8gcmVzdWx0c1syXS50cmltKCkgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGxzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lID0gZG9jdW1lbnQubGluZUF0KGRvY3VtZW50LmxpbmVDb3VudCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDZWxsID0gY2VsbHNbY2VsbHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBwcmV2aW91c0NlbGwucmFuZ2UgPSBuZXcgdnNjb2RlXzEuUmFuZ2UocHJldmlvdXNDZWxsLnJhbmdlLnN0YXJ0LCBsaW5lLnJhbmdlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5mb3JtIHRoZSBlZGl0b3IgY29udGV4dCB0aGF0IHdlIGhhdmUgY2VsbHMsIGZpcmUgYW5kIGZvcmdldCBpcyBvayBvbiB0aGUgcHJvbWlzZSBoZXJlXG4gICAgICAgIC8vIGFzIHdlIGRvbid0IGNhcmUgdG8gd2FpdCBmb3IgdGhpcyBjb250ZXh0IHRvIGJlIHNldCBhbmQgd2UgY2FuJ3QgZG8gYW55dGhpbmcgaWYgaXQgZmFpbHNcbiAgICAgICAgZWRpdG9yQ29udGV4dC5zZXQoY2VsbHMubGVuZ3RoID4gMCkuY2F0Y2goKTtcbiAgICAgICAgcmV0dXJuIGNlbGxzO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIHRlbGVtZXRyeV8xLmNhcHR1cmVUZWxlbWV0cnkoY29uc3RhbnRzXzEuVGVsZW1ldHJ5LlJ1bkFsbENlbGxzKVxuXSwgQ29kZVdhdGNoZXIucHJvdG90eXBlLCBcInJ1bkFsbENlbGxzXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgdGVsZW1ldHJ5XzEuY2FwdHVyZVRlbGVtZXRyeShjb25zdGFudHNfMS5UZWxlbWV0cnkuUnVuQ2VsbClcbl0sIENvZGVXYXRjaGVyLnByb3RvdHlwZSwgXCJydW5DZWxsXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgdGVsZW1ldHJ5XzEuY2FwdHVyZVRlbGVtZXRyeShjb25zdGFudHNfMS5UZWxlbWV0cnkuUnVuQ3VycmVudENlbGwpXG5dLCBDb2RlV2F0Y2hlci5wcm90b3R5cGUsIFwicnVuQ3VycmVudENlbGxcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICB0ZWxlbWV0cnlfMS5jYXB0dXJlVGVsZW1ldHJ5KGNvbnN0YW50c18xLlRlbGVtZXRyeS5SdW5DdXJyZW50Q2VsbEFuZEFkdmFuY2UpXG5dLCBDb2RlV2F0Y2hlci5wcm90b3R5cGUsIFwicnVuQ3VycmVudENlbGxBbmRBZHZhbmNlXCIsIG51bGwpO1xuZXhwb3J0cy5Db2RlV2F0Y2hlciA9IENvZGVXYXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29kZXdhdGNoZXIuanMubWFwIl19